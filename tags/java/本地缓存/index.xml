<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java/本地缓存 on luolin1024</title>
    <link>https://luolin1024.github.io/tags/java/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</link>
    <description>Recent content in Java/本地缓存 on luolin1024</description>
    <generator>Hugo -- 0.114.0</generator>
    <language>zh-cn</language>
    <atom:link href="https://luolin1024.github.io/tags/java/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java本地缓存</title>
      <link>https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</link>
      <pubDate>Sat, 11 Feb 2023 00:32:19 +0800</pubDate>
      <guid>https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</guid>
      <description>&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;对一个java后台开发者而言，提到缓存，第一反应就是redis和memcache。利用这类缓存足以解决大多数的性能问题了，并且java针对这两者也都有非常成熟的api可供使用。但是我们也要知道，这两种都属于remote cache（分布式缓存），应用的进程和缓存的进程通常分布在不同的服务器上，不同进程之间通过RPC或HTTP的方式通信。这种缓存的优点是缓存和应用服务解耦，支持大数据量的存储，缺点是数据要经过网络传输，性能上会有一定损耗。与分布式缓存对应的是本地缓存，缓存的进程和应用进程是同一个，数据的读写都在一个进程内完成，这种方式的优点是没有网络开销，访问速度很快。缺点是受JVM内存的限制，不适合存放大数据。本篇文章我们主要主要讨论Java本地缓存的的一些常用方案。&lt;/p&gt;
&lt;h3 id=&#34;本地缓存常用技术&#34;&gt;本地缓存常用技术&lt;/h3&gt;
&lt;p&gt;本地缓存和应用同属于一个进程，使用不当会影响服务稳定性，所以通常需要考虑更多的因素，例如容量限制、过期策略、淘汰策略、自动刷新等。常用的本地缓存方案有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据HashMap自实现本地缓存&lt;/li&gt;
&lt;li&gt;Guava Cache&lt;/li&gt;
&lt;li&gt;Caffeine&lt;/li&gt;
&lt;li&gt;Encache&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来说，对于本地缓存的方案中，笔者比较推荐Caffeine，性能上遥遥领先。虽然Encache功能更为丰富，甚至提供了持久化和集群的功能，但是这些功能完全可以依靠其他方式实现。真实的业务工程中，建议使用Caffeine作为本地缓存，另外使用redis或者memcache作为分布式缓存，构造多级缓存体系，保证性能和可靠性。下面分别进行介绍：&lt;/p&gt;
&lt;h4 id=&#34;1-根据hashmap自定义实现本地缓存&#34;&gt;1. 根据HashMap自定义实现本地缓存&lt;/h4&gt;
&lt;p&gt;缓存的本质就是存储在内存中的KV数据结构，对应的就是jdk中的HashMap，但是要实现缓存，还需要考虑并发安全性、容量限制等策略，下面简单介绍一种利用LinkedHashMap实现缓存的方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;LRUCache&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LinkedHashMap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;     &lt;span class=&#34;cm&#34;&gt;/**      * 可重入读写锁，保证并发读写安全性      */&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReentrantReadWriteLock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readWriteLock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReentrantReadWriteLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readLock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readWriteLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;readLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;writeLock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readWriteLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;writeLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;     &lt;span class=&#34;cm&#34;&gt;/**      * 缓存大小限制      */&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;         &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maxSize&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;maxSize&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;readLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;         &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;             &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;finally&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;             &lt;span class=&#34;n&#34;&gt;readLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;writeLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;         &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;             &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;finally&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;             &lt;span class=&#34;n&#34;&gt;writeLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;removeEldestEntry&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Entry&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eldest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;复制代码LinkedHashMap维持了一个链表结构，用来存储节点的插入顺序或者访问顺序（二选一），并且内部封装了一些业务逻辑，只需要覆盖removeEldestEntry方法，便可以实现缓存的LRU淘汰策略。此外我们利用读写锁，保障缓存的并发安全性。需要注意的是，这个示例并不支持过期时间淘汰的策略。自实现缓存的方式，优点是实现简单，不需要引入第三方包，比较适合一些简单的业务场景。缺点是如果需要更多的特性，需要定制化开发，成本会比较高，并且稳定性和可靠性也难以保障。对于比较复杂的场景，建议使用比较稳定的开源工具。&lt;/p&gt;
&lt;h4 id=&#34;2-基于guava-cache实现本地缓存&#34;&gt;2. 基于Guava Cache实现本地缓存&lt;/h4&gt;
&lt;p&gt;Guava是Google团队开源的一款 Java 核心增强库，包含集合、并发原语、缓存、IO、反射等工具箱，性能和稳定性上都有保障，应用十分广泛。Guava Cache支持很多特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持最大容量限制&lt;/li&gt;
&lt;li&gt;支持两种过期删除策略（插入时间和访问时间）&lt;/li&gt;
&lt;li&gt;支持简单的统计功能&lt;/li&gt;
&lt;li&gt;基于LRU算法实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Guava Cache的使用非常简单，首先需要引入maven包：&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;com.google.guava&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;guava&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;18.0&lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt; 复制代码一个简单的示例代码如下：public class GuavaCacheTest {     public static void main(String[] args) throws Exception {         //创建guava cache         Cache&amp;lt;String, String&amp;gt; loadingCache = CacheBuilder.newBuilder()                 //cache的初始容量                 .initialCapacity(5)                 //cache最大缓存数                 .maximumSize(10)                 //设置写缓存后n秒钟过期                 .expireAfterWrite(17, TimeUnit.SECONDS)                 //设置读写缓存后n秒钟过期,实际很少用到,类似于expireAfterWrite                 //.expireAfterAccess(17, TimeUnit.SECONDS)                 .build();         String key = &amp;ldquo;key&amp;rdquo;;         // 往缓存写数据         loadingCache.put(key, &amp;ldquo;v&amp;rdquo;);         // 获取value的值，如果key不存在，调用collable方法获取value值加载到key中再返回         String value = loadingCache.get(key, new Callable&lt;!-- raw HTML omitted --&gt;() {             @Override             public String call() throws Exception {                 return getValueFromDB(key);             }         });         // 删除key         loadingCache.invalidate(key);     }     private static String getValueFromDB(String key) {         return &amp;ldquo;v&amp;rdquo;;     } } 复制代码总体来说，Guava Cache是一款十分优异的缓存工具，功能丰富，线程安全，足以满足工程化使用，以上代码只介绍了一般的用法，实际上springboot对guava也有支持，利用配置文件或者注解可以轻松集成到代码中。&lt;/p&gt;
&lt;h4 id=&#34;3-caffeine&#34;&gt;3. Caffeine&lt;/h4&gt;
&lt;p&gt;Caffeine是基于java8实现的新一代缓存工具，缓存性能接近理论最优。可以看作是Guava Cache的增强版，功能上两者类似，不同的是Caffeine采用了一种结合LRU、LFU优点的算法：W-TinyLFU，在性能上有明显的优越性。Caffeine的使用，首先需要引入maven包：&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;com.github.ben-manes.caffeine&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;caffeine&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;2.5.5&lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt; 复制代码使用上和Guava Cache基本类似：public class CaffeineCacheTest {     public static void main(String[] args) throws Exception {         //创建guava cache         Cache&amp;lt;String, String&amp;gt; loadingCache = Caffeine.newBuilder()                 //cache的初始容量                 .initialCapacity(5)                 //cache最大缓存数                 .maximumSize(10)                 //设置写缓存后n秒钟过期                 .expireAfterWrite(17, TimeUnit.SECONDS)                 //设置读写缓存后n秒钟过期,实际很少用到,类似于expireAfterWrite                 //.expireAfterAccess(17, TimeUnit.SECONDS)                 .build();         String key = &amp;ldquo;key&amp;rdquo;;         // 往缓存写数据         loadingCache.put(key, &amp;ldquo;v&amp;rdquo;);         // 获取value的值，如果key不存在，获取value后再返回         String value = loadingCache.get(key, CaffeineCacheTest::getValueFromDB);         // 删除key         loadingCache.invalidate(key);     }     private static String getValueFromDB(String key) {         return &amp;ldquo;v&amp;rdquo;;     } } 复制代码相比Guava Cache来说，Caffeine无论从功能上和性能上都有明显优势。同时两者的API类似，使用Guava Cache的代码很容易可以切换到Caffeine，节省迁移成本。需要注意的是，SpringFramework5.0（SpringBoot2.0）同样放弃了Guava Cache的本地缓存方案，转而使用Caffeine。&lt;/p&gt;
&lt;h4 id=&#34;4-encache&#34;&gt;4. Encache&lt;/h4&gt;
&lt;p&gt;Encache是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。同Caffeine和Guava Cache相比，Encache的功能更加丰富，扩展性更强：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多种缓存淘汰算法，包括LRU、LFU和FIFO&lt;/li&gt;
&lt;li&gt;缓存支持堆内存储、堆外存储、磁盘存储（支持持久化）三种&lt;/li&gt;
&lt;li&gt;支持多种集群方案，解决数据共享问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Encache的使用，首先需要导入maven包：&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;org.ehcache&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;ehcache&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;3.8.0&lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt; 复制代码以下是一个简单的使用案例：public class EncacheTest {     public static void main(String[] args) throws Exception {         // 声明一个cacheBuilder         CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder()                 .withCache(&amp;ldquo;encacheInstance&amp;rdquo;, CacheConfigurationBuilder                         //声明一个容量为20的堆内缓存                         .newCacheConfigurationBuilder(String.class,String.class, ResourcePoolsBuilder.heap(20)))                 .build(true);         // 获取Cache实例         Cache&amp;lt;String,String&amp;gt; myCache =  cacheManager.getCache(&amp;ldquo;encacheInstance&amp;rdquo;, String.class, String.class);         // 写缓存         myCache.put(&amp;ldquo;key&amp;rdquo;,&amp;ldquo;v&amp;rdquo;);         // 读缓存         String value = myCache.get(&amp;ldquo;key&amp;rdquo;);         // 移除换粗         cacheManager.removeCache(&amp;ldquo;myCache&amp;rdquo;);         cacheManager.close();     } } 复制代码&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;从易用性角度，Guava Cache、Caffeine和Encache都有十分成熟的接入方案，使用简单。&lt;/li&gt;
&lt;li&gt;从功能性角度，Guava Cache和Caffeine功能类似，都是只支持堆内缓存，Encache相比功能更为丰富&lt;/li&gt;
&lt;li&gt;从性能上进行比较，Caffeine最优、GuavaCache次之，Encache最差(下图是三者的性能对比结果）&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>Java本地缓存</title>
      <link>https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</link>
      <pubDate>Sat, 11 Feb 2023 00:32:19 +0800</pubDate>
      <guid>https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</guid>
      <description>&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;对一个java后台开发者而言，提到缓存，第一反应就是redis和memcache。利用这类缓存足以解决大多数的性能问题了，并且java针对这两者也都有非常成熟的api可供使用。但是我们也要知道，这两种都属于remote cache（分布式缓存），应用的进程和缓存的进程通常分布在不同的服务器上，不同进程之间通过RPC或HTTP的方式通信。这种缓存的优点是缓存和应用服务解耦，支持大数据量的存储，缺点是数据要经过网络传输，性能上会有一定损耗。与分布式缓存对应的是本地缓存，缓存的进程和应用进程是同一个，数据的读写都在一个进程内完成，这种方式的优点是没有网络开销，访问速度很快。缺点是受JVM内存的限制，不适合存放大数据。本篇文章我们主要主要讨论Java本地缓存的的一些常用方案。&lt;/p&gt;
&lt;h3 id=&#34;本地缓存常用技术&#34;&gt;本地缓存常用技术&lt;/h3&gt;
&lt;p&gt;本地缓存和应用同属于一个进程，使用不当会影响服务稳定性，所以通常需要考虑更多的因素，例如容量限制、过期策略、淘汰策略、自动刷新等。常用的本地缓存方案有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据HashMap自实现本地缓存&lt;/li&gt;
&lt;li&gt;Guava Cache&lt;/li&gt;
&lt;li&gt;Caffeine&lt;/li&gt;
&lt;li&gt;Encache&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来说，对于本地缓存的方案中，笔者比较推荐Caffeine，性能上遥遥领先。虽然Encache功能更为丰富，甚至提供了持久化和集群的功能，但是这些功能完全可以依靠其他方式实现。真实的业务工程中，建议使用Caffeine作为本地缓存，另外使用redis或者memcache作为分布式缓存，构造多级缓存体系，保证性能和可靠性。下面分别进行介绍：&lt;/p&gt;
&lt;h4 id=&#34;1-根据hashmap自定义实现本地缓存&#34;&gt;1. 根据HashMap自定义实现本地缓存&lt;/h4&gt;
&lt;p&gt;缓存的本质就是存储在内存中的KV数据结构，对应的就是jdk中的HashMap，但是要实现缓存，还需要考虑并发安全性、容量限制等策略，下面简单介绍一种利用LinkedHashMap实现缓存的方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;LRUCache&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LinkedHashMap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;     &lt;span class=&#34;cm&#34;&gt;/**      * 可重入读写锁，保证并发读写安全性      */&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReentrantReadWriteLock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readWriteLock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReentrantReadWriteLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readLock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readWriteLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;readLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;writeLock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readWriteLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;writeLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;     &lt;span class=&#34;cm&#34;&gt;/**      * 缓存大小限制      */&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;         &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maxSize&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;maxSize&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;readLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;         &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;             &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;finally&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;             &lt;span class=&#34;n&#34;&gt;readLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;writeLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;         &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;             &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;finally&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;             &lt;span class=&#34;n&#34;&gt;writeLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;removeEldestEntry&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Entry&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eldest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;复制代码LinkedHashMap维持了一个链表结构，用来存储节点的插入顺序或者访问顺序（二选一），并且内部封装了一些业务逻辑，只需要覆盖removeEldestEntry方法，便可以实现缓存的LRU淘汰策略。此外我们利用读写锁，保障缓存的并发安全性。需要注意的是，这个示例并不支持过期时间淘汰的策略。自实现缓存的方式，优点是实现简单，不需要引入第三方包，比较适合一些简单的业务场景。缺点是如果需要更多的特性，需要定制化开发，成本会比较高，并且稳定性和可靠性也难以保障。对于比较复杂的场景，建议使用比较稳定的开源工具。&lt;/p&gt;
&lt;h4 id=&#34;2-基于guava-cache实现本地缓存&#34;&gt;2. 基于Guava Cache实现本地缓存&lt;/h4&gt;
&lt;p&gt;Guava是Google团队开源的一款 Java 核心增强库，包含集合、并发原语、缓存、IO、反射等工具箱，性能和稳定性上都有保障，应用十分广泛。Guava Cache支持很多特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持最大容量限制&lt;/li&gt;
&lt;li&gt;支持两种过期删除策略（插入时间和访问时间）&lt;/li&gt;
&lt;li&gt;支持简单的统计功能&lt;/li&gt;
&lt;li&gt;基于LRU算法实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Guava Cache的使用非常简单，首先需要引入maven包：&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;com.google.guava&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;guava&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;18.0&lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt; 复制代码一个简单的示例代码如下：public class GuavaCacheTest {     public static void main(String[] args) throws Exception {         //创建guava cache         Cache&amp;lt;String, String&amp;gt; loadingCache = CacheBuilder.newBuilder()                 //cache的初始容量                 .initialCapacity(5)                 //cache最大缓存数                 .maximumSize(10)                 //设置写缓存后n秒钟过期                 .expireAfterWrite(17, TimeUnit.SECONDS)                 //设置读写缓存后n秒钟过期,实际很少用到,类似于expireAfterWrite                 //.expireAfterAccess(17, TimeUnit.SECONDS)                 .build();         String key = &amp;ldquo;key&amp;rdquo;;         // 往缓存写数据         loadingCache.put(key, &amp;ldquo;v&amp;rdquo;);         // 获取value的值，如果key不存在，调用collable方法获取value值加载到key中再返回         String value = loadingCache.get(key, new Callable&lt;!-- raw HTML omitted --&gt;() {             @Override             public String call() throws Exception {                 return getValueFromDB(key);             }         });         // 删除key         loadingCache.invalidate(key);     }     private static String getValueFromDB(String key) {         return &amp;ldquo;v&amp;rdquo;;     } } 复制代码总体来说，Guava Cache是一款十分优异的缓存工具，功能丰富，线程安全，足以满足工程化使用，以上代码只介绍了一般的用法，实际上springboot对guava也有支持，利用配置文件或者注解可以轻松集成到代码中。&lt;/p&gt;
&lt;h4 id=&#34;3-caffeine&#34;&gt;3. Caffeine&lt;/h4&gt;
&lt;p&gt;Caffeine是基于java8实现的新一代缓存工具，缓存性能接近理论最优。可以看作是Guava Cache的增强版，功能上两者类似，不同的是Caffeine采用了一种结合LRU、LFU优点的算法：W-TinyLFU，在性能上有明显的优越性。Caffeine的使用，首先需要引入maven包：&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;com.github.ben-manes.caffeine&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;caffeine&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;2.5.5&lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt; 复制代码使用上和Guava Cache基本类似：public class CaffeineCacheTest {     public static void main(String[] args) throws Exception {         //创建guava cache         Cache&amp;lt;String, String&amp;gt; loadingCache = Caffeine.newBuilder()                 //cache的初始容量                 .initialCapacity(5)                 //cache最大缓存数                 .maximumSize(10)                 //设置写缓存后n秒钟过期                 .expireAfterWrite(17, TimeUnit.SECONDS)                 //设置读写缓存后n秒钟过期,实际很少用到,类似于expireAfterWrite                 //.expireAfterAccess(17, TimeUnit.SECONDS)                 .build();         String key = &amp;ldquo;key&amp;rdquo;;         // 往缓存写数据         loadingCache.put(key, &amp;ldquo;v&amp;rdquo;);         // 获取value的值，如果key不存在，获取value后再返回         String value = loadingCache.get(key, CaffeineCacheTest::getValueFromDB);         // 删除key         loadingCache.invalidate(key);     }     private static String getValueFromDB(String key) {         return &amp;ldquo;v&amp;rdquo;;     } } 复制代码相比Guava Cache来说，Caffeine无论从功能上和性能上都有明显优势。同时两者的API类似，使用Guava Cache的代码很容易可以切换到Caffeine，节省迁移成本。需要注意的是，SpringFramework5.0（SpringBoot2.0）同样放弃了Guava Cache的本地缓存方案，转而使用Caffeine。&lt;/p&gt;
&lt;h4 id=&#34;4-encache&#34;&gt;4. Encache&lt;/h4&gt;
&lt;p&gt;Encache是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。同Caffeine和Guava Cache相比，Encache的功能更加丰富，扩展性更强：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多种缓存淘汰算法，包括LRU、LFU和FIFO&lt;/li&gt;
&lt;li&gt;缓存支持堆内存储、堆外存储、磁盘存储（支持持久化）三种&lt;/li&gt;
&lt;li&gt;支持多种集群方案，解决数据共享问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Encache的使用，首先需要导入maven包：&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;org.ehcache&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;ehcache&lt;!-- raw HTML omitted --&gt;     &lt;!-- raw HTML omitted --&gt;3.8.0&lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt; 复制代码以下是一个简单的使用案例：public class EncacheTest {     public static void main(String[] args) throws Exception {         // 声明一个cacheBuilder         CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder()                 .withCache(&amp;ldquo;encacheInstance&amp;rdquo;, CacheConfigurationBuilder                         //声明一个容量为20的堆内缓存                         .newCacheConfigurationBuilder(String.class,String.class, ResourcePoolsBuilder.heap(20)))                 .build(true);         // 获取Cache实例         Cache&amp;lt;String,String&amp;gt; myCache =  cacheManager.getCache(&amp;ldquo;encacheInstance&amp;rdquo;, String.class, String.class);         // 写缓存         myCache.put(&amp;ldquo;key&amp;rdquo;,&amp;ldquo;v&amp;rdquo;);         // 读缓存         String value = myCache.get(&amp;ldquo;key&amp;rdquo;);         // 移除换粗         cacheManager.removeCache(&amp;ldquo;myCache&amp;rdquo;);         cacheManager.close();     } } 复制代码&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;从易用性角度，Guava Cache、Caffeine和Encache都有十分成熟的接入方案，使用简单。&lt;/li&gt;
&lt;li&gt;从功能性角度，Guava Cache和Caffeine功能类似，都是只支持堆内缓存，Encache相比功能更为丰富&lt;/li&gt;
&lt;li&gt;从性能上进行比较，Caffeine最优、GuavaCache次之，Encache最差(下图是三者的性能对比结果）&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
  </channel>
</rss>
