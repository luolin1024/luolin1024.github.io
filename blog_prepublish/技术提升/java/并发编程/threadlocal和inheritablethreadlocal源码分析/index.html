<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ThreadLocal和InheritableThreadLocal源码分析 | luolin1024</title><meta name=keywords content="Java/Java基础,源码分析"><meta name=description content="ThreadLocal分析 什么是ThreadLocal ThreadLocal是一种变量类型，与普通的局部变量和全局变量所不同的是，Threa"><meta name=author content="luolin"><link rel=canonical href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/threadlocal%E5%92%8Cinheritablethreadlocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/><script defer src=https://blogcounter.luolin.us.kg/script.js data-website-id=c8850e2c-16aa-465e-aa6f-5392c9397317></script>
<script src=/js/umami-stats.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luolin1024.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://luolin1024.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://luolin1024.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://luolin1024.github.io/apple-touch-icon.png><link rel=mask-icon href=https://luolin1024.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><html><head><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css><style>body{font-family:lxgw wenkai lite,sans-serif;font-family:lxgw wenkai screen,sans-serif}</style></head></html><meta property="og:title" content="ThreadLocal和InheritableThreadLocal源码分析"><meta property="og:description" content="ThreadLocal分析 什么是ThreadLocal ThreadLocal是一种变量类型，与普通的局部变量和全局变量所不同的是，Threa"><meta property="og:type" content="article"><meta property="og:url" content="https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/threadlocal%E5%92%8Cinheritablethreadlocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="article:section" content="blog_prepublish"><meta property="article:published_time" content="2024-02-21T11:30:51+08:00"><meta property="article:modified_time" content="2024-03-21T00:55:26+08:00"><meta property="og:site_name" content="luolin的博客"><meta name=twitter:card content="summary"><meta name=twitter:title content="ThreadLocal和InheritableThreadLocal源码分析"><meta name=twitter:description content="ThreadLocal分析 什么是ThreadLocal ThreadLocal是一种变量类型，与普通的局部变量和全局变量所不同的是，Threa"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog_prepublishes","item":"https://luolin1024.github.io/blog_prepublish/"},{"@type":"ListItem","position":2,"name":"ThreadLocal和InheritableThreadLocal源码分析","item":"https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/threadlocal%E5%92%8Cinheritablethreadlocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ThreadLocal和InheritableThreadLocal源码分析","name":"ThreadLocal和InheritableThreadLocal源码分析","description":"ThreadLocal分析 什么是ThreadLocal ThreadLocal是一种变量类型，与普通的局部变量和全局变量所不同的是，Threa","keywords":["Java/Java基础","源码分析"],"articleBody":"ThreadLocal分析 什么是ThreadLocal ThreadLocal是一种变量类型，与普通的局部变量和全局变量所不同的是，ThreadLocal是一种“线程变量”，在jdk中一开始设计是用来存储线程上下文的，作用域与线程绑定。通常使用private 和 static修饰 ThreadLocal变量，此时表示作用域为本类中的线程使用到的方法。当线程被销毁，对应的线程变量也会被清除（个人是这样理解的，因为使用Entry存储对应的value是虚引用，当对应的线程被销毁时，线程）。但是在当前大多数使用线程池来管理线程的场景中，线程是不会被销毁的，这也就代表着使用线程池管理线程的时候，必须要手动清除线程变量， 否则将会造成内存泄漏。\nThreadLocal变量通常被static修饰，好处是它可以避免重复创建TSO(Thread Specific Object，即ThreadLocal所关联的对象)所导致的浪费。坏处是这样做可能正好形成内存泄漏所需的条件。\n在大多数精密的多线程代码中都有ThreadLocal的影子，理解ThreadLocal能帮助我们更好的理解java多线程。\nThreadLocal使用示例 public class ThreadlocalTest { private ThreadLocal\u003cString\u003e threadLocal = new ThreadLocal\u003c\u003e(); public void test() throws InterruptedException { threadLocal.set(\"parent\"); Thread thread = new Thread(() -\u003e { System.out.println(Thread.currentThread().getName() + \" ===\u003e \" + threadLocal.get()); threadLocal.set(\"child\"); System.out.println(Thread.currentThread().getName() + \" ===\u003e \" + threadLocal.get()); }); thread.start(); thread.join(); System.out.println(Thread.currentThread().getName() + \" ===\u003e \" + threadLocal.get()); } public static void main(String[] args) throws InterruptedException { new ThreadlocalTest().test(); } } 输出结果：\nThread-0 ===\u003e null Thread-0 ===\u003e child main ===\u003e parent 通过上面的示例，我们可以看到ThreadLocal在每个线程之间独立的，父线程与子线程之间的ThreadLocal与子线程的ThreadLocal之间没有关系，真正的每个线程拥有自己的属性。\n源码分析 首先，我们要清楚，Thread、ThreadLocal、ThreadLocalMap还有ThreadLocalMap.Entry的关系；它们的关系可以理解为每一个线程拥有一个ThreadLocal.ThreadLocalMap属性的变量，而这个ThreadLocalMap变量中有一个内部类Entry，Entry中存储的键值对，其中referent是线程变量的引用，value则是我们通过ThreadLocal.set()设置的内容。多线程环境中，Thread、ThreadLocal、ThreadLocalMap还有ThreadLocalMap.Entry之间的关系如下图所示： Thread中存储ThreadLocal.ThreadLocalMap属性的有两个变量：threadLocals、inheritableThreadLocals；threadLocals不可以在父子线程之间使用，而inheritableThreadLocals可以在父子线程之间使用。\npublic class Thread implements Runnable { /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; } ThreadLocal.set()方法以及set相关操作：\npublic class ThreadLocal\u003cT\u003e{ private final int threadLocalHashCode = nextHashCode(); public void set(T value) { // 获取当前调用者线程 Thread t = Thread.currentThread(); // 尝试根据调用者线程获取该线程的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) // 向ThreadLocalMap插入键值对 map.set(this, value); else // 在第一次set()的时候创建该线程的ThreadLocalMap createMap(t, value); } // 在第一次set()或get()的时候创建该线程的ThreadLocalMap void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } static class ThreadLocalMap{ /** * 存储Entry的 */ private Entry[] table; // ThreadLocalMap 中用来存储键值对 static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u003c?\u003e k, Object v) { super(k); value = v; } } // 初始化ThreadLocalMap ThreadLocalMap(ThreadLocal\u003c?\u003e firstKey, Object firstValue) { // 初始Entry大小为16 table = new Entry[INITIAL_CAPACITY]; // 地址下标 = 第一个（当前）ThreadLocal变量的hash值\u002615，获取一个必然小于15的值作为下标存储value int i = firstKey.threadLocalHashCode \u0026 (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; // 设置扩容阀值 = Entry大小(INITIAL_CAPACITY) * 2/3; 后续扩容大小 = 当前大小*2，扩容阀值=Entry大小* 2/3; setThreshold(INITIAL_CAPACITY); } // 向Entry中插入键值对 private void set(ThreadLocal\u003c?\u003e key, Object value) { // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; // 计算标 int i = key.threadLocalHashCode \u0026 (len-1); // 使用 开放寻址法 解决hash冲突 for (Entry e = tab[i]; e != null; // nextIndex(i,len) = ((i + 1 \u003c len) ? i + 1 : 0) e = tab[i = nextIndex(i, len)]) { // 获取e的ThreadLocal引用 ThreadLocal\u003c?\u003e k = e.get(); // e的ThreadLocal引用 == 当前调用者线程，则将value覆盖原有value if (k == key) { e.value = value; return; } // e的ThreadLocal引用为空，而e不为空，说明当前的ThreadLocal引用已经不可达， // 将需要set的value和对应的ThreadLocal引用设置到当前的Entry中 // 该操作需要先解决ThreadLocal引用失效导致的hash值计算不连续问题，关于这一点可以了解一下hash表开放寻址法查找元素 if (k == null) { replaceStaleEntry(key, value, i); return; } } // 新增结点到Entry tab[i] = new Entry(key, value); int sz = ++size; // 尝试清除后续hash table中的结点 if (!cleanSomeSlots(i, sz) \u0026\u0026 sz \u003e= threshold) rehash(); } } } ThreadLocal.get()方法以及get相关操作：\npublic class ThreadLocal\u003cT\u003e { // 获取当前线程变量对应的value public T get() { // 获取当前调用者线程 Thread t = Thread.currentThread(); // 获取线程中的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) { // 获取ThreadLocalMap中的Entry ThreadLocalMap.Entry e = map.getEntry(this); // Enrty不为空时尝试获取对应的value； // 为空则表示在这之前进行过get()操作创建了ThreadLocalMap if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } // 返回默认值，默认返回null,可以通过子类重写该方法修改默认返回值 return setInitialValue(); } // 获取当前线程的ThreadLocalMap ThreadLocalMap getMap(Thread t) { // 返回Thread中的ThreadLocalMap return t.threadLocals; } /** * ThreadLocal中用来存储\u003c当前线程,存储的值\u003e键值对 */ static class ThreadLocalMap { // hash表 private Entry[] table; // 返回ThreadLocalMap中的hash表 private Entry getEntry(ThreadLocal\u003c?\u003e key) { // 计算 hashKey int i = key.threadLocalHashCode \u0026 (table.length - 1); // 从hashTable Entry[]中获取对应的ThreadLocal引用 Entry e = table[i]; if (e != null \u0026\u0026 e.get() == key) // Entry命中的条件是e存在与Entry \u0026\u0026 e的引用和key相同 return e; else // Entry未命中（e不存在||存在hash冲突导致e的引用和key不同），向后寻找可以命中的Entry或者返回最后一个null结点 return getEntryAfterMiss(key, i, e); } // 由于hash冲突导致的未命中，向后寻找可以命中的Entry，或者 private Entry getEntryAfterMiss(ThreadLocal\u003c?\u003e key, int i, Entry e) { Entry[] tab = table; int len = tab.length; // e为空就直接返回null // e不为空则向后寻找可以命中的Entry while (e != null) { ThreadLocal\u003c?\u003e k = e.get(); if (k == key) // hash命中，返回e return e; if (k == null) // 找到最后一个可以存放 expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null; } } /** * 还没有通过set创建ThreadLocalMap时，使用get方法，默认创建一个ThreadLocalMap * @return the initial value */ private T setInitialValue() { // ThreadLocal类默认返回null T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else // 创建一个新的ThreadLocalMap createMap(t, value); return value; } /** * ThreadLocal中value默认值，可以通过子类重写该方法修改get()默认返回的值 * @return the initial value for this thread-local */ protected T initialValue() { return null; } } ThreadLocal.remove()方法以及get相关操作：\npublic class ThreadLocal\u003cT\u003e { public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); } static class ThreadLocalMap { private void remove(ThreadLocal\u003c?\u003e key) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode \u0026 (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { e.clear(); expungeStaleEntry(i); return; } } } private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; // 清除Entry中staleSlot下标的值 tab[staleSlot].value = null; tab[staleSlot] = null; size--; // 整理hashTable（Entry） Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal\u003c?\u003e k = e.get(); if (k == null) { e.value = null; tab[i] = null; size--; } else { int h = k.threadLocalHashCode \u0026 (len - 1); if (h != i) { tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; } } } return i; } } } ThreadLocal总结 对于一个Thread来说，ThreadLocal只是其一个属性变量，其中使用ThreadLocalMap存放了该线程所存放的所有线程变量，主要以形式存储。 Thread与ThreadLocal是一对一的关系，也就是说Thread与ThreadLocalMap是一对一的关系。 ThreadLocal为什么要使用ThreadLocalMap? 因为一个Thread中可能存放多个线程变量，存在一对多的关系，所以一个Thread要能够对应多个线程变量，线程变量还需要与自己的value一对一对应。 哈希冲突存在两种解决方法：开放寻址法和链表法。ThreadLocalMap中的Entry为什么要使用开放寻址法？使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。但是另一方面，链表法需要额外的空间，当结点规模较小时，开放寻址法较为节省空间。对于ThreadLocal线程变量来讲，将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放寻址法中的冲突，从而提高平均查找速度。 对于ThreadLocal中的ThreadLocalMap、ThreadLocalMap.Entry有疑问，看看hashTable的原理，可以很好的帮助理解ThreadLocal。 下图可以很好的帮助理解ThreadLocal变量、ThreadLocal.ThreadLocalMap以及Entry之间的关系。 InheritableThreadLocal分析 InheritableThreadLocal使用背景 其实上述讲解ThreadLocal的时候，使用到的示例中展示了ThreadLocal无法在父子线程之间传递ThreadLocal变量。但是有些时候我们是需要将父线程中的某些线程变量传递给子线程的，比如父线程的线程变量存储着用户信息，此时父线程开启了多个子线程，子线程需要把用户信息以及一些业务信息存储到数据库中，那么这个时候就需要把用户的信息传递给子线程的；对于这种场景有两种解决方案，方案一就是把用户信息提取为一个普通局部变量，作为参数传递给子线程的方法中；方案二则是将用户信息直接传给子线程，但是单纯凭借ThreadLocal无法实现变量传递，此时InheritableThreadLocal就可以开始发挥作用了。\nInheritableThreadLocal使用实例 public class ThreadlocalTest { private ThreadLocal\u003cString\u003e threadLocal = new InheritableThreadLocal\u003c\u003e(); public void test() throws InterruptedException { threadLocal.set(\"parent\"); Thread thread = new Thread(() -\u003e { System.out.println(Thread.currentThread().getName() + \" ===\u003e \" + threadLocal.get()); threadLocal.set(\"child\"); System.out.println(Thread.currentThread().getName() + \" ===\u003e \" + threadLocal.get()); }); thread.start(); thread.join(); System.out.println(Thread.currentThread().getName() + \" ===\u003e \" + threadLocal.get()); } public static void main(String[] args) throws InterruptedException { new ThreadlocalTest().test(); } } 输出结果\nThread-0 ===\u003e parent Thread-0 ===\u003e child main ===\u003e parent 源码分析 先看下InheritableThreadLocal类，以及它所重写ThreadLocal的setMap和getMap方法：\npublic class InheritableThreadLocal\u003cT\u003e extends ThreadLocal\u003cT\u003e { /** * 创建子线程的时候浅拷贝返回父线程持有的InheritableThreadLocal.ThreadLocalMap.Entry.value的引用 * 如果想要深拷贝value，则需要子类重写该方法 * * @param parentValue the parent thread's value * @return the child thread's initial value */ protected T childValue(T parentValue) { return parentValue; } /** * 返回线程t的inheritableThreadLocals变量 * 使用时利用向下转型获取InheritableThreadLocal变量，所以InheritableThreadLocal.get()只会获取对应线程的inheritableThreadLocals变量 * * @param t the current thread */ ThreadLocalMap getMap(Thread t) { return t.inheritableThreadLocals; } /** * 设置线程t的inheritableThreadLocals变量 * 使用时利用向下转型设置InheritableThreadLocal变量，所以InheritableThreadLocal.set()只会设置对应线程的inheritableThreadLocals变量 * @param t the current thread * @param firstValue value for the initial entry of the table. */ void createMap(Thread t, T firstValue) { t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); } } 那子线程又是如何获取到父线程的ThreadLocal变量呢，查看Thread类中新建一个线程源码：\npublic class Thread implements Runnable { /* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; public Thread(Runnable target) { init(null, target, \"Thread-\" + nextThreadNum(), 0); } private void init(ThreadGroup g, Runnable target, String name, long stackSize) { init(g, target, name, stackSize, null, true); } /** * Initializes a Thread. 初始化线程 * * @param g the Thread group * @param target the object whose run() method gets called * @param name the name of the new Thread * @param stackSize the desired stack size for the new thread, or * zero to indicate that this parameter is to be ignored. * @param acc the AccessControlContext to inherit, or * AccessController.getContext() if null * @param inheritThreadLocals if {@code true}, inherit initial values for * inheritable thread-locals from the constructing thread 是否从调用方继承InheritableThreadLocal变量 */ private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { if (name == null) { throw new NullPointerException(\"name cannot be null\"); } this.name = name; // 当前调用者线程为父线程 Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) { /* Determine if it's an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) { g = security.getThreadGroup(); } /* If the security doesn't have a strong opinion of the matter use the parent thread group. */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) { if (isCCLOverridden(getClass())) { security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); } } g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); // 如果inheritThreadLocals == true（默认new Thread都是true）并且父线程存在InheritableThreadLocal变量， // 当前线程将会复制父线程的InheritableThreadLocal到本线程中 if (inheritThreadLocals \u0026\u0026 parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); } } public class ThreadLocal\u003cT\u003e { // 子线程复制父线程的ThreadLocal变量 static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) { return new ThreadLocalMap(parentMap); } static class ThreadLocalMap { // 深拷贝ThreadLocalMap,浅拷贝Entry中的value private ThreadLocalMap(ThreadLocalMap parentMap) { Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j \u003c len; j++) { Entry e = parentTable[j]; if (e != null) { @SuppressWarnings(\"unchecked\") ThreadLocal\u003cObject\u003e key = (ThreadLocal\u003cObject\u003e) e.get(); if (key != null) { // 拷贝父线程持有的InheritableThreadLocal.ThreadLocalMap.Entry.value // InheritableThreadLocal默认使用浅拷贝（直接返回引用） // 如果需要深拷贝，则需要InheritableThreadLocal子类重写childValue方法 Object value = key.childValue(e.value); Entry c = new Entry(key, value); // 计算下一个hash下标 int h = key.threadLocalHashCode \u0026 (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; } } } } } } InheritableThreadLocal 拷贝机制 InheritableThreadLocal与ThreadLocal的区别就在于父线程可以将InheritableThreadLocal变量深拷贝一份到子线程中，但是Entry中的vaue则是浅拷贝，也就是说假如子线程通过get()方法获取到对应的value之后，直接修改value的值，父线程中获取到的value的值也会进行相应的修改，如下：\npublic class ThreadlocalTest { private ThreadLocal\u003cPerson\u003e threadLocal = new InheritableThreadLocal\u003c\u003e(); public void test() throws InterruptedException { threadLocal.set(new Person(\"a\", 13)); Thread thread = new Thread(() -\u003e { System.out.println(Thread.currentThread().getName() + \" ===\u003e \" + threadLocal.get().toString() + \"===\u003e\" +threadLocal.get().hashCode()); threadLocal.get().setAge(15); System.out.println(Thread.currentThread().getName() + \" ===\u003e \" + threadLocal.get().toString() + \"===\u003e\" +threadLocal.get().hashCode()); }); thread.start(); thread.join(); System.out.println(Thread.currentThread().getName() + \" ===\u003e \" + threadLocal.get().toString() + \"===\u003e\" +threadLocal.get().hashCode()); threadLocal.remove(); System.out.println(); } public static void main(String[] args) throws InterruptedException { new ThreadlocalTest().test(); } } 输出结果：\nThread-0 ===\u003e Person{name='a', age=13}===\u003e2024651980 Thread-0 ===\u003e Person{name='a', age=15}===\u003e2024651980 main ===\u003e Person{name='a', age=15}===\u003e2024651980 在子线程中修改了get()获取到的value中的属性值，父线程通过get()获取到的value也发生了改变，且父子线程中get()获取到的value的地址是相同的。\nInheritableThreadLocal总结 相比较ThreadLocal，InheritableThreadLocal完成了父子线程之间线程变量的传递，实现方案是父线程创建子线程的时候，父线程本身新建了一个InheritableThreadLocal变量存放inheritableThreadLocals中，子线程从父线程拷贝inheritableThreadLocals属性，而InheritableThreadLocal继承自ThreadLocal，使得其完美承载了ThreadLocal的属性，只是重写其中的setMap和getMap方法后使得其返回的map为线程的inheritableThreadLocals变量。 父线程新建子线程的时候，ThreadLocalMap是深拷贝，但是Entry中的value是浅拷贝，也就意味着子线程通过get()获取到的value修改之后，父线程再通过get()获取value也是修改过后的。 思考 目前已经很少出现通过自己手动new Thread启动线程了，一般都是通过ThreadPool实现。在使用线程池的情况下，因为线程池是复用线程，不会重复创建，而InheritableThreadLocal是在创建子线程的时候才会将父线程的值复制到子线程中，但是线程池不会重复创建，所以多次使用后，仍然记录的是第一次提交任务时的外部线程的值，会造成数据的错误。\n","wordCount":"6677","inLanguage":"en","datePublished":"2024-02-21T11:30:51+08:00","dateModified":"2024-03-21T00:55:26+08:00","author":{"@type":"Person","name":"luolin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/threadlocal%E5%92%8Cinheritablethreadlocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},"publisher":{"@type":"Organization","name":"luolin1024","logo":{"@type":"ImageObject","url":"https://luolin1024.github.io/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luolin1024.github.io accesskey=h title="luolin的博客 (Alt + H)">luolin的博客</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://luolin1024.github.io/posts title=📚文章><span>📚文章</span></a></li><li><a href=https://luolin1024.github.io/archives/ title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luolin1024.github.io/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luolin1024.github.io/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luolin1024.github.io/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luolin1024.github.io/links title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://luolin1024.github.io>Home</a>&nbsp;»&nbsp;<a href=https://luolin1024.github.io/blog_prepublish/>Blog_prepublishes</a></div><h1 class="post-title entry-hint-parent">ThreadLocal和InheritableThreadLocal源码分析</h1><div class=post-meta><span title='2024-02-21 11:30:51 +0800 +0800'>2024-02-21</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;6677 words&nbsp;·&nbsp;luolin
本文总阅读量 <span id=umami_value_page_pv></span> 次
本文总访客量 <span id=umami_value_page_uv></span> 人</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#threadlocal%e5%88%86%e6%9e%90 aria-label=ThreadLocal分析>ThreadLocal分析</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afthreadlocal aria-label=什么是ThreadLocal>什么是ThreadLocal</a></li><li><a href=#threadlocal%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b aria-label=ThreadLocal使用示例>ThreadLocal使用示例</a></li><li><a href=#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 aria-label=源码分析>源码分析</a></li><li><a href=#threadlocal%e6%80%bb%e7%bb%93 aria-label=ThreadLocal总结>ThreadLocal总结</a></li></ul></li><li><a href=#inheritablethreadlocal%e5%88%86%e6%9e%90 aria-label=InheritableThreadLocal分析>InheritableThreadLocal分析</a><ul><li><a href=#inheritablethreadlocal%e4%bd%bf%e7%94%a8%e8%83%8c%e6%99%af aria-label=InheritableThreadLocal使用背景>InheritableThreadLocal使用背景</a></li><li><a href=#inheritablethreadlocal%e4%bd%bf%e7%94%a8%e5%ae%9e%e4%be%8b aria-label=InheritableThreadLocal使用实例>InheritableThreadLocal使用实例</a></li><li><a href=#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-1 aria-label=源码分析>源码分析</a></li><li><a href=#inheritablethreadlocal-%e6%8b%b7%e8%b4%9d%e6%9c%ba%e5%88%b6 aria-label="InheritableThreadLocal 拷贝机制">InheritableThreadLocal 拷贝机制</a></li><li><a href=#inheritablethreadlocal%e6%80%bb%e7%bb%93 aria-label=InheritableThreadLocal总结>InheritableThreadLocal总结</a></li></ul></li><li><a href=#%e6%80%9d%e8%80%83 aria-label=思考>思考</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=threadlocal分析>ThreadLocal分析<a hidden class=anchor aria-hidden=true href=#threadlocal分析>#</a></h3><h4 id=什么是threadlocal>什么是ThreadLocal<a hidden class=anchor aria-hidden=true href=#什么是threadlocal>#</a></h4><p>ThreadLocal是一种变量类型，与普通的局部变量和全局变量所不同的是，ThreadLocal是一种“线程变量”，在jdk中一开始设计是用来存储线程上下文的，作用域与线程绑定。通常使用private 和 static修饰 ThreadLocal变量，此时表示作用域为本类中的线程使用到的方法。当线程被销毁，对应的线程变量也会被清除（个人是这样理解的，因为使用Entry存储对应的value是虚引用，当对应的线程被销毁时，线程）。但是在当前大多数使用线程池来管理线程的场景中，线程是不会被销毁的，这也就代表着使用线程池管理线程的时候，必须要手动清除线程变量， 否则将会造成内存泄漏。</p><blockquote><p>ThreadLocal变量通常被static修饰，好处是它可以避免重复创建TSO(Thread Specific Object，即ThreadLocal所关联的对象)所导致的浪费。坏处是这样做可能正好形成内存泄漏所需的条件。</p></blockquote><p>在大多数精密的多线程代码中都有ThreadLocal的影子，理解ThreadLocal能帮助我们更好的理解java多线程。</p><h4 id=threadlocal使用示例>ThreadLocal使用示例<a hidden class=anchor aria-hidden=true href=#threadlocal使用示例>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ThreadlocalTest</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>ThreadLocal</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>threadLocal</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadLocal</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>threadLocal</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=s>&#34;parent&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>thread</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; ===&gt; &#34;</span> <span class=o>+</span> <span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=n>threadLocal</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=s>&#34;child&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; ===&gt; &#34;</span> <span class=o>+</span> <span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>});</span>
</span></span><span class=line><span class=cl>        <span class=n>thread</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>thread</span><span class=o>.</span><span class=na>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; ===&gt; &#34;</span> <span class=o>+</span> <span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>ThreadlocalTest</span><span class=o>().</span><span class=na>test</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Thread</span><span class=o>-</span><span class=mi>0</span> <span class=o>===&gt;</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span><span class=o>-</span><span class=mi>0</span> <span class=o>===&gt;</span> <span class=n>child</span>
</span></span><span class=line><span class=cl><span class=n>main</span> <span class=o>===&gt;</span> <span class=n>parent</span>
</span></span></code></pre></div><p>通过上面的示例，我们可以看到ThreadLocal在每个线程之间独立的，父线程与子线程之间的ThreadLocal与子线程的ThreadLocal之间没有关系，真正的每个线程拥有自己的属性。</p><h4 id=源码分析>源码分析<a hidden class=anchor aria-hidden=true href=#源码分析>#</a></h4><p>首先，我们要清楚，Thread、ThreadLocal、ThreadLocalMap还有ThreadLocalMap.Entry的关系；它们的关系可以理解为每一个线程拥有一个ThreadLocal.ThreadLocalMap属性的变量，而这个ThreadLocalMap变量中有一个内部类Entry，Entry中存储的&lt;referent， value>键值对，其中referent是线程变量的引用，value则是我们通过ThreadLocal.set()设置的内容。多线程环境中，Thread、ThreadLocal、ThreadLocalMap还有ThreadLocalMap.Entry之间的关系如下图所示：<div class=post-img-view><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/luolin1024/image@main/img/1601362147957-992b4249-a404-4246-b036-c0fed3f751b4.png><img src=https://cdn.jsdelivr.net/gh/luolin1024/image@main/img/1601362147957-992b4249-a404-4246-b036-c0fed3f751b4.png alt="ThreadLocal (5).png"></a></div></p><p>Thread中存储ThreadLocal.ThreadLocalMap属性的有两个变量：threadLocals、inheritableThreadLocals；threadLocals不可以在父子线程之间使用，而inheritableThreadLocals可以在父子线程之间使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Thread</span> <span class=kd>implements</span> <span class=n>Runnable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* ThreadLocal values pertaining to this thread. This map is maintained
</span></span></span><span class=line><span class=cl><span class=cm>     * by the ThreadLocal class. */</span>
</span></span><span class=line><span class=cl>    <span class=n>ThreadLocal</span><span class=o>.</span><span class=na>ThreadLocalMap</span> <span class=n>threadLocals</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>ThreadLocal.set()方法以及set相关操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ThreadLocal</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>threadLocalHashCode</span> <span class=o>=</span> <span class=n>nextHashCode</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>set</span><span class=o>(</span><span class=n>T</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取当前调用者线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Thread</span> <span class=n>t</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 尝试根据调用者线程获取该线程的ThreadLocalMap
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ThreadLocalMap</span> <span class=n>map</span> <span class=o>=</span> <span class=n>getMap</span><span class=o>(</span><span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>map</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 向ThreadLocalMap插入&lt;ThreadLocal, value&gt;键值对
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>map</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 在第一次set()的时候创建该线程的ThreadLocalMap
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>createMap</span><span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 在第一次set()或get()的时候创建该线程的ThreadLocalMap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>createMap</span><span class=o>(</span><span class=n>Thread</span> <span class=n>t</span><span class=o>,</span> <span class=n>T</span> <span class=n>firstValue</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span><span class=o>.</span><span class=na>threadLocals</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadLocalMap</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>firstValue</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>	<span class=kd>static</span> <span class=kd>class</span> <span class=nc>ThreadLocalMap</span><span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>         * 存储Entry的
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=n>Entry</span><span class=o>[]</span> <span class=n>table</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// ThreadLocalMap 中用来存储&lt;ThreadLocal引用变量,ThreadLocal 所保存的值&gt;键值对
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Entry</span> <span class=kd>extends</span> <span class=n>WeakReference</span><span class=o>&lt;</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/** The value associated with this ThreadLocal. */</span>
</span></span><span class=line><span class=cl>            <span class=n>Object</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>Entry</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>k</span><span class=o>,</span> <span class=n>Object</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=kd>super</span><span class=o>(</span><span class=n>k</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=n>value</span> <span class=o>=</span> <span class=n>v</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 初始化ThreadLocalMap
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ThreadLocalMap</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>firstKey</span><span class=o>,</span> <span class=n>Object</span> <span class=n>firstValue</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 初始Entry大小为16
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>table</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>[</span><span class=n>INITIAL_CAPACITY</span><span class=o>];</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 地址下标 = 第一个（当前）ThreadLocal变量的hash值&amp;15，获取一个必然小于15的值作为下标存储value
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>firstKey</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>INITIAL_CAPACITY</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>table</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>(</span><span class=n>firstKey</span><span class=o>,</span> <span class=n>firstValue</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>size</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 设置扩容阀值 = Entry大小(INITIAL_CAPACITY) * 2/3; 后续扩容大小 = 当前大小*2，扩容阀值=Entry大小* 2/3;
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>setThreshold</span><span class=o>(</span><span class=n>INITIAL_CAPACITY</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 向Entry中插入&lt;ThreadLocal,value&gt;键值对
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=kd>private</span> <span class=kt>void</span> <span class=nf>set</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>key</span><span class=o>,</span> <span class=n>Object</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// We don&#39;t use a fast path as with get() because it is at
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// least as common to use set() to create new entries as
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// it is to replace existing ones, in which case, a fast
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// path would fail more often than not.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>            <span class=n>Entry</span><span class=o>[]</span> <span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 计算标
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>len</span><span class=o>-</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// 使用 开放寻址法 解决hash冲突
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=o>(</span><span class=n>Entry</span> <span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
</span></span><span class=line><span class=cl>                 <span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                 <span class=c1>// nextIndex(i,len) = ((i + 1 &lt; len) ? i + 1 : 0)
</span></span></span><span class=line><span class=cl><span class=c1></span>                 <span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>len</span><span class=o>)])</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 获取e的ThreadLocal引用
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1>// e的ThreadLocal引用 == 当前调用者线程，则将value覆盖原有value
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>e</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1>// e的ThreadLocal引用为空，而e不为空，说明当前的ThreadLocal引用已经不可达，
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 将需要set的value和对应的ThreadLocal引用设置到当前的Entry中
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 该操作需要先解决ThreadLocal引用失效导致的hash值计算不连续问题，关于这一点可以了解一下hash表开放寻址法查找元素
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>replaceStaleEntry</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// 新增结点到Entry
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>sz</span> <span class=o>=</span> <span class=o>++</span><span class=n>size</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 尝试清除后续hash table中的结点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(!</span><span class=n>cleanSomeSlots</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>sz</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>sz</span> <span class=o>&gt;=</span> <span class=n>threshold</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>rehash</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>ThreadLocal.get()方法以及get相关操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ThreadLocal</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取当前线程变量对应的value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>public</span> <span class=n>T</span> <span class=nf>get</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取当前调用者线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Thread</span> <span class=n>t</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取线程中的ThreadLocalMap
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ThreadLocalMap</span> <span class=n>map</span> <span class=o>=</span> <span class=n>getMap</span><span class=o>(</span><span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>map</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 获取ThreadLocalMap中的Entry
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>ThreadLocalMap</span><span class=o>.</span><span class=na>Entry</span> <span class=n>e</span> <span class=o>=</span> <span class=n>map</span><span class=o>.</span><span class=na>getEntry</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Enrty不为空时尝试获取对应的value；
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 为空则表示在这之前进行过get()操作创建了ThreadLocalMap
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=n>T</span> <span class=n>result</span> <span class=o>=</span> <span class=o>(</span><span class=n>T</span><span class=o>)</span><span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 返回默认值，默认返回null,可以通过子类重写该方法修改默认返回值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>setInitialValue</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取当前线程的ThreadLocalMap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ThreadLocalMap</span> <span class=nf>getMap</span><span class=o>(</span><span class=n>Thread</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 返回Thread中的ThreadLocalMap
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>t</span><span class=o>.</span><span class=na>threadLocals</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * ThreadLocal中用来存储&lt;当前线程,存储的值&gt;键值对
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>class</span> <span class=nc>ThreadLocalMap</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// hash表
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>private</span> <span class=n>Entry</span><span class=o>[]</span> <span class=n>table</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    	<span class=c1>// 返回ThreadLocalMap中的hash表
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>private</span> <span class=n>Entry</span> <span class=nf>getEntry</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 计算 hashKey
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>table</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 从hashTable Entry[]中获取对应的ThreadLocal引用
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>Entry</span> <span class=n>e</span> <span class=o>=</span> <span class=n>table</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>()</span> <span class=o>==</span> <span class=n>key</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Entry命中的条件是e存在与Entry &amp;&amp; e的引用和key相同
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>return</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Entry未命中（e不存在||存在hash冲突导致e的引用和key不同），向后寻找可以命中的Entry或者返回最后一个null结点
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>return</span> <span class=n>getEntryAfterMiss</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>e</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 由于hash冲突导致的未命中，向后寻找可以命中的Entry，或者
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kd>private</span> <span class=n>Entry</span> <span class=nf>getEntryAfterMiss</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>key</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=n>Entry</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Entry</span><span class=o>[]</span> <span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>            <span class=c1>// e为空就直接返回null
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// e不为空则向后寻找可以命中的Entry
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>while</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=n>key</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// hash命中，返回e
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>return</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// 找到最后一个可以存放
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>expungeStaleEntry</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                    <span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>len</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                <span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 还没有通过set创建ThreadLocalMap时，使用get方法，默认创建一个ThreadLocalMap
</span></span></span><span class=line><span class=cl><span class=cm>     * @return the initial value
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>T</span> <span class=nf>setInitialValue</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ThreadLocal类默认返回null
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>T</span> <span class=n>value</span> <span class=o>=</span> <span class=n>initialValue</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>t</span> <span class=o>=</span> <span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>ThreadLocalMap</span> <span class=n>map</span> <span class=o>=</span> <span class=n>getMap</span><span class=o>(</span><span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>map</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>map</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 创建一个新的ThreadLocalMap
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>createMap</span><span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>value</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * ThreadLocal中value默认值，可以通过子类重写该方法修改get()默认返回的值
</span></span></span><span class=line><span class=cl><span class=cm>     * @return the initial value for this thread-local
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>protected</span> <span class=n>T</span> <span class=nf>initialValue</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>ThreadLocal.remove()方法以及get相关操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ThreadLocal</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kt>void</span> <span class=nf>remove</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>         <span class=n>ThreadLocalMap</span> <span class=n>m</span> <span class=o>=</span> <span class=n>getMap</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>());</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=o>(</span><span class=n>m</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>             <span class=n>m</span><span class=o>.</span><span class=na>remove</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
</span></span><span class=line><span class=cl>     <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=kd>class</span> <span class=nc>ThreadLocalMap</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    	<span class=kd>private</span> <span class=kt>void</span> <span class=nf>remove</span><span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Entry</span><span class=o>[]</span> <span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>len</span><span class=o>-</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=o>(</span><span class=n>Entry</span> <span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
</span></span><span class=line><span class=cl>                 <span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                 <span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>len</span><span class=o>)])</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>()</span> <span class=o>==</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>e</span><span class=o>.</span><span class=na>clear</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                    <span class=n>expungeStaleEntry</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=kd>private</span> <span class=kt>int</span> <span class=nf>expungeStaleEntry</span><span class=o>(</span><span class=kt>int</span> <span class=n>staleSlot</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Entry</span><span class=o>[]</span> <span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1>// 清除Entry中staleSlot下标的值
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>tab</span><span class=o>[</span><span class=n>staleSlot</span><span class=o>].</span><span class=na>value</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>tab</span><span class=o>[</span><span class=n>staleSlot</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>size</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// 整理hashTable（Entry）
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>Entry</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>i</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=o>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>staleSlot</span><span class=o>,</span> <span class=n>len</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                 <span class=o>(</span><span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                 <span class=n>i</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>len</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>ThreadLocal</span><span class=o>&lt;?&gt;</span> <span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>e</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>size</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=n>k</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>len</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=o>(</span><span class=n>h</span> <span class=o>!=</span> <span class=n>i</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                        <span class=c1>// Unlike Knuth 6.4 Algorithm R, we must scan until
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=c1>// null because multiple entries could have been stale.
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=k>while</span> <span class=o>(</span><span class=n>tab</span><span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                            <span class=n>h</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>h</span><span class=o>,</span> <span class=n>len</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                        <span class=n>tab</span><span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                    <span class=o>}</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h4 id=threadlocal总结>ThreadLocal总结<a hidden class=anchor aria-hidden=true href=#threadlocal总结>#</a></h4><ol><li>对于一个Thread来说，ThreadLocal只是其一个属性变量，其中使用ThreadLocalMap存放了该线程所存放的所有线程变量，主要以&lt;ThreadLocal, value>形式存储。</li><li>Thread与ThreadLocal是一对一的关系，也就是说Thread与ThreadLocalMap是一对一的关系。</li><li>ThreadLocal为什么要使用ThreadLocalMap? 因为一个Thread中可能存放多个线程变量，存在一对多的关系，所以一个Thread要能够对应多个线程变量，线程变量还需要与自己的value一对一对应。</li><li>哈希冲突存在两种解决方法：开放寻址法和链表法。ThreadLocalMap中的Entry为什么要使用开放寻址法？使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。但是另一方面，链表法需要额外的空间，当结点规模较小时，开放寻址法较为节省空间。对于ThreadLocal线程变量来讲，将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放寻址法中的冲突，从而提高平均查找速度。</li><li>对于ThreadLocal中的ThreadLocalMap、ThreadLocalMap.Entry有疑问，看看hashTable的原理，可以很好的帮助理解ThreadLocal。</li><li>下图可以很好的帮助理解ThreadLocal变量、ThreadLocal.ThreadLocalMap以及Entry之间的关系。</li></ol><p><div class=post-img-view><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/luolin1024/image@main/img/1601294325514-b914afdb-9b58-47ef-81ec-af78387e8514.png><img src=https://cdn.jsdelivr.net/gh/luolin1024/image@main/img/1601294325514-b914afdb-9b58-47ef-81ec-af78387e8514.png alt="ThreadLocal (3).png"></a></div></p><h3 id=inheritablethreadlocal分析>InheritableThreadLocal分析<a hidden class=anchor aria-hidden=true href=#inheritablethreadlocal分析>#</a></h3><h4 id=inheritablethreadlocal使用背景>InheritableThreadLocal使用背景<a hidden class=anchor aria-hidden=true href=#inheritablethreadlocal使用背景>#</a></h4><p>其实上述讲解ThreadLocal的时候，使用到的示例中展示了ThreadLocal无法在父子线程之间传递ThreadLocal变量。但是有些时候我们是需要将父线程中的某些线程变量传递给子线程的，比如父线程的线程变量存储着用户信息，此时父线程开启了多个子线程，子线程需要把用户信息以及一些业务信息存储到数据库中，那么这个时候就需要把用户的信息传递给子线程的；对于这种场景有两种解决方案，方案一就是把用户信息提取为一个普通局部变量，作为参数传递给子线程的方法中；方案二则是将用户信息直接传给子线程，但是单纯凭借ThreadLocal无法实现变量传递，此时InheritableThreadLocal就可以开始发挥作用了。</p><h4 id=inheritablethreadlocal使用实例>InheritableThreadLocal使用实例<a hidden class=anchor aria-hidden=true href=#inheritablethreadlocal使用实例>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ThreadlocalTest</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>ThreadLocal</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>threadLocal</span> <span class=o>=</span> <span class=k>new</span> <span class=n>InheritableThreadLocal</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>threadLocal</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=s>&#34;parent&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>thread</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; ===&gt; &#34;</span> <span class=o>+</span> <span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=n>threadLocal</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=s>&#34;child&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; ===&gt; &#34;</span> <span class=o>+</span> <span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>});</span>
</span></span><span class=line><span class=cl>        <span class=n>thread</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>thread</span><span class=o>.</span><span class=na>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; ===&gt; &#34;</span> <span class=o>+</span> <span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>ThreadlocalTest</span><span class=o>().</span><span class=na>test</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Thread</span><span class=o>-</span><span class=mi>0</span> <span class=o>===&gt;</span> <span class=n>parent</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span><span class=o>-</span><span class=mi>0</span> <span class=o>===&gt;</span> <span class=n>child</span>
</span></span><span class=line><span class=cl><span class=n>main</span> <span class=o>===&gt;</span> <span class=n>parent</span>
</span></span></code></pre></div><h4 id=源码分析-1>源码分析<a hidden class=anchor aria-hidden=true href=#源码分析-1>#</a></h4><p>先看下InheritableThreadLocal类，以及它所重写ThreadLocal的setMap和getMap方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>InheritableThreadLocal</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>ThreadLocal</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 创建子线程的时候浅拷贝返回父线程持有的InheritableThreadLocal.ThreadLocalMap.Entry.value的引用
</span></span></span><span class=line><span class=cl><span class=cm>     * 如果想要深拷贝value，则需要子类重写该方法
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @param parentValue the parent thread&#39;s value
</span></span></span><span class=line><span class=cl><span class=cm>     * @return the child thread&#39;s initial value
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>protected</span> <span class=n>T</span> <span class=nf>childValue</span><span class=o>(</span><span class=n>T</span> <span class=n>parentValue</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>parentValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 返回线程t的inheritableThreadLocals变量
</span></span></span><span class=line><span class=cl><span class=cm>     * 使用时利用向下转型获取InheritableThreadLocal变量，所以InheritableThreadLocal.get()只会获取对应线程的inheritableThreadLocals变量
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @param t the current thread
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>ThreadLocalMap</span> <span class=nf>getMap</span><span class=o>(</span><span class=n>Thread</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=n>t</span><span class=o>.</span><span class=na>inheritableThreadLocals</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 设置线程t的inheritableThreadLocals变量
</span></span></span><span class=line><span class=cl><span class=cm>     * 使用时利用向下转型设置InheritableThreadLocal变量，所以InheritableThreadLocal.set()只会设置对应线程的inheritableThreadLocals变量
</span></span></span><span class=line><span class=cl><span class=cm>     * @param t the current thread
</span></span></span><span class=line><span class=cl><span class=cm>     * @param firstValue value for the initial entry of the table.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>createMap</span><span class=o>(</span><span class=n>Thread</span> <span class=n>t</span><span class=o>,</span> <span class=n>T</span> <span class=n>firstValue</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span><span class=o>.</span><span class=na>inheritableThreadLocals</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ThreadLocalMap</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>firstValue</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>那子线程又是如何获取到父线程的ThreadLocal变量呢，查看Thread类中新建一个线程源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Thread</span> <span class=kd>implements</span> <span class=n>Runnable</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * InheritableThreadLocal values pertaining to this thread. This map is
</span></span></span><span class=line><span class=cl><span class=cm>     * maintained by the InheritableThreadLocal class.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>ThreadLocal</span><span class=o>.</span><span class=na>ThreadLocalMap</span> <span class=n>inheritableThreadLocals</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>Thread</span><span class=o>(</span><span class=n>Runnable</span> <span class=n>target</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>init</span><span class=o>(</span><span class=kc>null</span><span class=o>,</span> <span class=n>target</span><span class=o>,</span> <span class=s>&#34;Thread-&#34;</span> <span class=o>+</span> <span class=n>nextThreadNum</span><span class=o>(),</span> <span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>init</span><span class=o>(</span><span class=n>ThreadGroup</span> <span class=n>g</span><span class=o>,</span> <span class=n>Runnable</span> <span class=n>target</span><span class=o>,</span> <span class=n>String</span> <span class=n>name</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                      <span class=kt>long</span> <span class=n>stackSize</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>init</span><span class=o>(</span><span class=n>g</span><span class=o>,</span> <span class=n>target</span><span class=o>,</span> <span class=n>name</span><span class=o>,</span> <span class=n>stackSize</span><span class=o>,</span> <span class=kc>null</span><span class=o>,</span> <span class=kc>true</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>	<span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Initializes a Thread. 初始化线程
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @param g the Thread group
</span></span></span><span class=line><span class=cl><span class=cm>     * @param target the object whose run() method gets called
</span></span></span><span class=line><span class=cl><span class=cm>     * @param name the name of the new Thread
</span></span></span><span class=line><span class=cl><span class=cm>     * @param stackSize the desired stack size for the new thread, or
</span></span></span><span class=line><span class=cl><span class=cm>     *        zero to indicate that this parameter is to be ignored.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param acc the AccessControlContext to inherit, or
</span></span></span><span class=line><span class=cl><span class=cm>     *            AccessController.getContext() if null
</span></span></span><span class=line><span class=cl><span class=cm>     * @param inheritThreadLocals if {@code true}, inherit initial values for
</span></span></span><span class=line><span class=cl><span class=cm>     *            inheritable thread-locals from the constructing thread 是否从调用方继承InheritableThreadLocal变量
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>init</span><span class=o>(</span><span class=n>ThreadGroup</span> <span class=n>g</span><span class=o>,</span> <span class=n>Runnable</span> <span class=n>target</span><span class=o>,</span> <span class=n>String</span> <span class=n>name</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                      <span class=kt>long</span> <span class=n>stackSize</span><span class=o>,</span> <span class=n>AccessControlContext</span> <span class=n>acc</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                      <span class=kt>boolean</span> <span class=n>inheritThreadLocals</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>name</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>NullPointerException</span><span class=o>(</span><span class=s>&#34;name cannot be null&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>name</span> <span class=o>=</span> <span class=n>name</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 当前调用者线程为父线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Thread</span> <span class=n>parent</span> <span class=o>=</span> <span class=n>currentThread</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>SecurityManager</span> <span class=n>security</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>getSecurityManager</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>g</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* Determine if it&#39;s an applet or not */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* If there is a security manager, ask the security manager
</span></span></span><span class=line><span class=cl><span class=cm>               what to do. */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>security</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>g</span> <span class=o>=</span> <span class=n>security</span><span class=o>.</span><span class=na>getThreadGroup</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* If the security doesn&#39;t have a strong opinion of the matter
</span></span></span><span class=line><span class=cl><span class=cm>               use the parent thread group. */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>g</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>g</span> <span class=o>=</span> <span class=n>parent</span><span class=o>.</span><span class=na>getThreadGroup</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* checkAccess regardless of whether or not threadgroup is
</span></span></span><span class=line><span class=cl><span class=cm>           explicitly passed in. */</span>
</span></span><span class=line><span class=cl>        <span class=n>g</span><span class=o>.</span><span class=na>checkAccess</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>         * Do we have the required permissions?
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>security</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>isCCLOverridden</span><span class=o>(</span><span class=n>getClass</span><span class=o>()))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>security</span><span class=o>.</span><span class=na>checkPermission</span><span class=o>(</span><span class=n>SUBCLASS_IMPLEMENTATION_PERMISSION</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>g</span><span class=o>.</span><span class=na>addUnstarted</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>group</span> <span class=o>=</span> <span class=n>g</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>daemon</span> <span class=o>=</span> <span class=n>parent</span><span class=o>.</span><span class=na>isDaemon</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>priority</span> <span class=o>=</span> <span class=n>parent</span><span class=o>.</span><span class=na>getPriority</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>security</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>isCCLOverridden</span><span class=o>(</span><span class=n>parent</span><span class=o>.</span><span class=na>getClass</span><span class=o>()))</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>.</span><span class=na>contextClassLoader</span> <span class=o>=</span> <span class=n>parent</span><span class=o>.</span><span class=na>getContextClassLoader</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>.</span><span class=na>contextClassLoader</span> <span class=o>=</span> <span class=n>parent</span><span class=o>.</span><span class=na>contextClassLoader</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>inheritedAccessControlContext</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                <span class=n>acc</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>?</span> <span class=n>acc</span> <span class=o>:</span> <span class=n>AccessController</span><span class=o>.</span><span class=na>getContext</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>target</span> <span class=o>=</span> <span class=n>target</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>setPriority</span><span class=o>(</span><span class=n>priority</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果inheritThreadLocals == true（默认new Thread都是true）并且父线程存在InheritableThreadLocal变量，
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 当前线程将会复制父线程的InheritableThreadLocal到本线程中
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>inheritThreadLocals</span> <span class=o>&amp;&amp;</span> <span class=n>parent</span><span class=o>.</span><span class=na>inheritableThreadLocals</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>.</span><span class=na>inheritableThreadLocals</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                <span class=n>ThreadLocal</span><span class=o>.</span><span class=na>createInheritedMap</span><span class=o>(</span><span class=n>parent</span><span class=o>.</span><span class=na>inheritableThreadLocals</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Stash the specified stack size in case the VM cares */</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>stackSize</span> <span class=o>=</span> <span class=n>stackSize</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Set thread ID */</span>
</span></span><span class=line><span class=cl>        <span class=n>tid</span> <span class=o>=</span> <span class=n>nextThreadID</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ThreadLocal</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 子线程复制父线程的ThreadLocal变量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>static</span> <span class=n>ThreadLocalMap</span> <span class=nf>createInheritedMap</span><span class=o>(</span><span class=n>ThreadLocalMap</span> <span class=n>parentMap</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>ThreadLocalMap</span><span class=o>(</span><span class=n>parentMap</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>	<span class=kd>static</span> <span class=kd>class</span> <span class=nc>ThreadLocalMap</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 深拷贝ThreadLocalMap,浅拷贝Entry中的value
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=kd>private</span> <span class=nf>ThreadLocalMap</span><span class=o>(</span><span class=n>ThreadLocalMap</span> <span class=n>parentMap</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Entry</span><span class=o>[]</span> <span class=n>parentTable</span> <span class=o>=</span> <span class=n>parentMap</span><span class=o>.</span><span class=na>table</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>parentTable</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=n>setThreshold</span><span class=o>(</span><span class=n>len</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>table</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>[</span><span class=n>len</span><span class=o>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>len</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Entry</span> <span class=n>e</span> <span class=o>=</span> <span class=n>parentTable</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>ThreadLocal</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span> <span class=n>key</span> <span class=o>=</span> <span class=o>(</span><span class=n>ThreadLocal</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;)</span> <span class=n>e</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                        <span class=c1>// 拷贝父线程持有的InheritableThreadLocal.ThreadLocalMap.Entry.value
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=c1>// InheritableThreadLocal默认使用浅拷贝（直接返回引用）
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=c1>// 如果需要深拷贝，则需要InheritableThreadLocal子类重写childValue方法
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=n>Object</span> <span class=n>value</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>childValue</span><span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                        <span class=n>Entry</span> <span class=n>c</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Entry</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                        <span class=c1>// 计算下一个hash下标
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>threadLocalHashCode</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>len</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                        <span class=k>while</span> <span class=o>(</span><span class=n>table</span><span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                            <span class=n>h</span> <span class=o>=</span> <span class=n>nextIndex</span><span class=o>(</span><span class=n>h</span><span class=o>,</span> <span class=n>len</span><span class=o>);</span>
</span></span><span class=line><span class=cl>                        <span class=n>table</span><span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>=</span> <span class=n>c</span><span class=o>;</span>
</span></span><span class=line><span class=cl>                        <span class=n>size</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>                    <span class=o>}</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h4 id=inheritablethreadlocal-拷贝机制>InheritableThreadLocal 拷贝机制<a hidden class=anchor aria-hidden=true href=#inheritablethreadlocal-拷贝机制>#</a></h4><p><div class=post-img-view><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/luolin1024/image@main/img/1601358479593-10e7d145-bfa5-46d9-9b42-9d724168e054.png><img src=https://cdn.jsdelivr.net/gh/luolin1024/image@main/img/1601358479593-10e7d145-bfa5-46d9-9b42-9d724168e054.png alt=InheritableThreadLocal.png></a></div>InheritableThreadLocal与ThreadLocal的区别就在于父线程可以将InheritableThreadLocal变量深拷贝一份到子线程中，但是Entry中的vaue则是浅拷贝，也就是说假如子线程通过get()方法获取到对应的value之后，直接修改value的值，父线程中获取到的value的值也会进行相应的修改，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ThreadlocalTest</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>ThreadLocal</span><span class=o>&lt;</span><span class=n>Person</span><span class=o>&gt;</span> <span class=n>threadLocal</span> <span class=o>=</span> <span class=k>new</span> <span class=n>InheritableThreadLocal</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>threadLocal</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=k>new</span> <span class=n>Person</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>,</span> <span class=mi>13</span><span class=o>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Thread</span> <span class=n>thread</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; ===&gt; &#34;</span> <span class=o>+</span> <span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>().</span><span class=na>toString</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;===&gt;&#34;</span> <span class=o>+</span><span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>().</span><span class=na>hashCode</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>().</span><span class=na>setAge</span><span class=o>(</span><span class=mi>15</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; ===&gt; &#34;</span> <span class=o>+</span> <span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>().</span><span class=na>toString</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;===&gt;&#34;</span> <span class=o>+</span><span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>().</span><span class=na>hashCode</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>});</span>
</span></span><span class=line><span class=cl>        <span class=n>thread</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>thread</span><span class=o>.</span><span class=na>join</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>Thread</span><span class=o>.</span><span class=na>currentThread</span><span class=o>().</span><span class=na>getName</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; ===&gt; &#34;</span> <span class=o>+</span> <span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>().</span><span class=na>toString</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;===&gt;&#34;</span> <span class=o>+</span><span class=n>threadLocal</span><span class=o>.</span><span class=na>get</span><span class=o>().</span><span class=na>hashCode</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>threadLocal</span><span class=o>.</span><span class=na>remove</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>InterruptedException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=n>ThreadlocalTest</span><span class=o>().</span><span class=na>test</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>输出结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Thread</span><span class=o>-</span><span class=mi>0</span> <span class=o>===&gt;</span> <span class=n>Person</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=sc>&#39;a&#39;</span><span class=o>,</span> <span class=n>age</span><span class=o>=</span><span class=mi>13</span><span class=o>}===&gt;</span><span class=mi>2024651980</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span><span class=o>-</span><span class=mi>0</span> <span class=o>===&gt;</span> <span class=n>Person</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=sc>&#39;a&#39;</span><span class=o>,</span> <span class=n>age</span><span class=o>=</span><span class=mi>15</span><span class=o>}===&gt;</span><span class=mi>2024651980</span>
</span></span><span class=line><span class=cl><span class=n>main</span> <span class=o>===&gt;</span> <span class=n>Person</span><span class=o>{</span><span class=n>name</span><span class=o>=</span><span class=sc>&#39;a&#39;</span><span class=o>,</span> <span class=n>age</span><span class=o>=</span><span class=mi>15</span><span class=o>}===&gt;</span><span class=mi>2024651980</span>
</span></span></code></pre></div><p>在子线程中修改了get()获取到的value中的属性值，父线程通过get()获取到的value也发生了改变，且父子线程中get()获取到的value的地址是相同的。</p><h4 id=inheritablethreadlocal总结>InheritableThreadLocal总结<a hidden class=anchor aria-hidden=true href=#inheritablethreadlocal总结>#</a></h4><ol><li>相比较ThreadLocal，InheritableThreadLocal完成了父子线程之间线程变量的传递，实现方案是父线程创建子线程的时候，父线程本身新建了一个InheritableThreadLocal变量存放inheritableThreadLocals中，子线程从父线程拷贝inheritableThreadLocals属性，而InheritableThreadLocal继承自ThreadLocal，使得其完美承载了ThreadLocal的属性，只是重写其中的setMap和getMap方法后使得其返回的map为线程的inheritableThreadLocals变量。</li><li>父线程新建子线程的时候，ThreadLocalMap是深拷贝，但是Entry中的value是浅拷贝，也就意味着子线程通过get()获取到的value修改之后，父线程再通过get()获取value也是修改过后的。</li></ol><h3 id=思考>思考<a hidden class=anchor aria-hidden=true href=#思考>#</a></h3><p>目前已经很少出现通过自己手动new Thread启动线程了，一般都是通过ThreadPool实现。在使用线程池的情况下，因为线程池是复用线程，不会重复创建，而InheritableThreadLocal是在创建子线程的时候才会将父线程的值复制到子线程中，但是线程池不会重复创建，所以多次使用后，仍然记录的是第一次提交任务时的外部线程的值，会造成数据的错误。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://luolin1024.github.io/tags/java/java%E5%9F%BA%E7%A1%80/>Java/Java基础</a></li><li><a href=https://luolin1024.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a></li></ul><nav class=paginav><a class=prev href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/sql%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2/><span class=title>« Prev</span><br><span>Sql联表查询</span></a>
<a class=next href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/uml-unified-modeling-language/><span class=title>Next »</span><br><span>UML统一建模语言</span></a></nav><div class=related-posts><h2>相关文章</h2><ul><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%93%E5%90%88threadlocal%E7%9A%84%E7%94%A8%E6%B3%95%E5%AE%9E%E4%BE%8B/>Java线程池结合ThreadLocal的用法实例</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/object%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>Object源码分析</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/spring/spring5-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/>Spring5 源码阅读环境搭建</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java-%E5%8F%8D%E5%B0%84/>Java-反射</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java8-stream/>Java8 Stream</a></li></ul></div></footer><link rel=stylesheet href=https://unpkg.com/@waline/client@v2/dist/waline.css><div id=waline></div><script type=module>
    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
    const locale = {
        nick: '昵称',
        nickError: '请填写昵称',
        mail: '邮箱',
        mailError: '请填写正确的邮件地址',
        link: '网址',
        optional: '可选',
        placeholder: '仅填写昵称即可发表回复。\n填写邮箱可收到回复提醒。\n评论区支持 Markdown 语法及预览。\n',
        sofa: '来发评论吧~',
        submit: '提交',
        like: '喜欢',
        cancelLike: '取消喜欢',
        reply: '回复',
        cancelReply: '取消回复',
        comment: '评论',
        refresh: '刷新',
        more: '加载更多...',
        preview: '预览',
        emoji: '表情',
        uploadImage: '上传图片',
        seconds: '秒前',
        minutes: '分钟前',
        hours: '小时前',
        days: '天前',
        now: '刚刚',
        uploading: '正在上传',
        login: '管理',
        logout: '退出',
        admin: '博主',
        sticky: '置顶',
        word: '字',
        wordHint: '评论字数应在 $0 到 $1 字之间！\n当前字数：$2',
        anonymous: '匿名',
        level0: '潜水',
        level1: '冒泡',
        level2: '吐槽',
        level3: '活跃',
        level4: '话痨',
        level5: '传说',
        gif: '表情包',
        gifSearchPlaceholder: '搜索表情包',
        profile: '个人资料',
        approved: '通过',
        waiting: '待审核',
        spam: '垃圾',
        unsticky: '取消置顶',
        oldest: '按倒序',
        latest: '按正序',
        hottest: '按热度',
        reactionTitle: '你认为这篇文章怎么样？',
    };
    init({
        
        el: '#waline',
        serverURL: 'https://blogcomments.luolin.online',
        locale,
        emoji: false,     
        search: false,    
        reaction: false,  
        requiredMeta: ['nick'],
        pageSize: 10,
        imageUploader: false,
        copyright: true,
        pageview: true,
        like: false,
    });
</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://luolin1024.github.io>luolin1024</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div>本站总访问量 <span id=umami_value_site_pv></span> 次
本站总访客数 <span id=umami_value_site_uv></span> 人
当前在线访客 <span id=umami_value_active_uv></span> 人</div><a href="https://icp.gov.moe/?keyword=20248618" target=_blank>萌ICP备20248618号</a></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>