<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java8 函数式编程和Lambda | luolin1024</title><meta name=keywords content="Java/Java基础"><meta name=description content="lambda 初识lambda表达式 一个简单的方法，比较两个Integer： public void Test1() { Comparator<Integer> com = new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { return Integer.compare(o1, o2); } }; TreeSet<Integer> treeSet = new TreeSet<>(com); } 下面的这个方法与上"><meta name=author content="luolin"><link rel=canonical href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8Clambda/><script defer src=https://blogcounter.luolin.us.kg/script.js data-website-id=c8850e2c-16aa-465e-aa6f-5392c9397317></script>
<script src=/js/umami-stats.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luolin1024.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://luolin1024.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://luolin1024.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://luolin1024.github.io/apple-touch-icon.png><link rel=mask-icon href=https://luolin1024.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><html><head><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css><style>body{font-family:lxgw wenkai lite,sans-serif;font-family:lxgw wenkai screen,sans-serif}</style></head></html><meta property="og:title" content="Java8 函数式编程和Lambda"><meta property="og:description" content="lambda 初识lambda表达式 一个简单的方法，比较两个Integer： public void Test1() { Comparator<Integer> com = new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { return Integer.compare(o1, o2); } }; TreeSet<Integer> treeSet = new TreeSet<>(com); } 下面的这个方法与上"><meta property="og:type" content="article"><meta property="og:url" content="https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8Clambda/"><meta property="article:section" content="blog_prepublish"><meta property="article:published_time" content="2023-02-11T00:32:19+08:00"><meta property="article:modified_time" content="2024-03-21T00:57:04+08:00"><meta property="og:site_name" content="luolin的博客"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java8 函数式编程和Lambda"><meta name=twitter:description content="lambda 初识lambda表达式 一个简单的方法，比较两个Integer： public void Test1() { Comparator<Integer> com = new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { return Integer.compare(o1, o2); } }; TreeSet<Integer> treeSet = new TreeSet<>(com); } 下面的这个方法与上"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog_prepublishes","item":"https://luolin1024.github.io/blog_prepublish/"},{"@type":"ListItem","position":2,"name":"Java8 函数式编程和Lambda","item":"https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8Clambda/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java8 函数式编程和Lambda","name":"Java8 函数式编程和Lambda","description":"lambda 初识lambda表达式 一个简单的方法，比较两个Integer： public void Test1() { Comparator\u0026lt;Integer\u0026gt; com = new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { return Integer.compare(o1, o2); } }; TreeSet\u0026lt;Integer\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(com); } 下面的这个方法与上","keywords":["Java/Java基础"],"articleBody":"lambda 初识lambda表达式 一个简单的方法，比较两个Integer：\npublic void Test1() { Comparator\u003cInteger\u003e com = new Comparator\u003cInteger\u003e() { @Override public int compare(Integer o1, Integer o2) { return Integer.compare(o1, o2); } }; TreeSet\u003cInteger\u003e treeSet = new TreeSet\u003c\u003e(com); } 下面的这个方法与上面的方法效果相同：\npublic void Test2() { Comparator\u003cInteger\u003e com = (x, y) -\u003e Integer.compare(x, y); TreeSet\u003cInteger\u003e treeSet = new TreeSet\u003c\u003e(com); } 从上面就可以看出lambda表达式可以极大地简化代码量现在有一个需求，找出所有年龄大于35的员工,Employee的实体类属性如下\nString name; int age; int salary; 创建一个List保存数据：\nList\u003cEmployee\u003e employees = Arrays.asList( new Employee(\"张三\", 11, 9000), new Employee(\"李四\", 33, 3000), new Employee(\"王五\", 44, 4000), new Employee(\"p8\", 55, 2000) ); 一开始，我们也许会选择一种最简单的方法去实现：\n@Test public List\u003cEmployee\u003e Test3() { List\u003cEmployee\u003e list = new ArrayList\u003c\u003e(); for (Employee employee : employees) { if (employee.age \u003e 35) { list.add(employee) } } return list; } 优化一、使用策略设计模式 自己新建实现类来过滤员工功能 然后有了一个新的需求，找出所有员工中工资高于3500的员工，此时就需要加方法了，然后也许还会有别的需求（姓李的员工）等，我们不可能每次加需求都要加方法，于是这时候可以采用策略设计模式，设计一个接口MyInterface,里面声明一个用于处理过滤员工的方法：\npublic interface MyInterface\u003cT\u003e { boolean filter(T t); } 编写一个专门用于过滤员工的方法：\n/** * 用于过滤 Employee * * @param list * @param myInterface * @return */ List\u003cEmployee\u003e filterEmployees(List\u003cEmployee\u003e list, MyInterface\u003cEmployee\u003e myInterface) { List\u003cEmployee\u003e emp = new ArrayList\u003c\u003e(); for (Employee employee : list) { if (myInterface.filter(employee)) { emp.add(employee); } } return emp; } 之后如果需要使用员工过滤的方法时，调用filterEmployees方法时传入MyInterface的具体实现类，这个实现类中重写好所需要的filter方法。\n使用内部匿名类来实现过滤员工功能 我们此时在调用的方法中就是传入一个匿名内部类，重写好我们所需要的方法即可：\n@Test public void test4() { List\u003cEmployee\u003e list = filterEmployees(employees, new MyInterface\u003cEmployee\u003e() { @Override public boolean filter(Employee employee) { if (employee.age \u003e 22) { return true; } return false; } }); for (Employee employee : list) { System.out.println(employee.name + \" \" + employee.age + \" \" + employee.salary); } } 优化二、使用lambda表达式 lambda表达式其实就是简化了使用匿名内部类的写法繁琐\n@Test public void test5() { List\u003cEmployee\u003e list = filterEmployees(employees, (employee -\u003e employee.age \u003e 22)); for (Employee employee : list) { System.out.println(employee.name + \" \" + employee.age + \" \" + employee.salary); } } lambda原理 在讲almbda原理之前先说下函数式接口FunctionalInterface，FunctionalInterface就是接口中只有一个抽象方法的接口，此时可以使用注解@FunctionalInterface，如果注解的接口内部有多个抽象方法，编译器会报错。那么这和lambda有什么关系呢，思考一下，如果使用lambda来替代一个匿名内部类的写法，我们使用lambda的时候是没有指明使用实现接口的哪个方法的，也就是说如果接口内有多个抽象方法，编译器就不知道lambda想要重写哪个方法，这个时候自然会报错。注意事项：\n保持Lambda表达式简短和一目了然，过长的Lambda表达式通常是危险的，因为代码越长越难以读懂，意图看起来也不明，并且代码也难以复用，测试难度也大。 使用@FunctionalInterface注解，否则他人修改了函数式接口后使用lambda的地方就用不了了。 不要在Lambda表达中执行有\"副作用\"的操作，“副作用\"是严重违背函数式编程的设计原则，比如在forEach操作里面操作外面的某个List或者设置某个Map这其实是不对的。 不要把Lambda表达式和匿名内部类同等对待。lambda和匿名内部类是有区别的，主要区别在于匿名内部类中的this和lambda中的this指代的是不同的实例。匿名内部类中的this指向当前匿名内部类的实例（且匿名内部类中的this只能指向内部类的实例，不能指向所在类的实例），而lambda中的this指向所在类的实例，测试如下： private String value = \"Enclosing scope value\"; @Test public void Test6() { int num = 333; MyInterface\u003cEmployee\u003e myInterface = new MyInterface\u003cEmployee\u003e() { String value = \"Inner class value\"; @Override public boolean filter(Employee employee) { System.out.println(\"resultIC(this):\"+this.value+num); System.out.println(\"resultIC(normal):\"+value+num); return false; } }; Employee employee = employees.get(0); myInterface.filter(employee); MyInterface\u003cEmployee\u003e myInterface1 = employee1 -\u003e { String value = \"Lambda value\"; System.out.println(\"resultLambda(normal):\"+value+num); System.out.println(\"resultLambda(this):\"+this.value+num); this.value = \"show\"; return true; }; System.out.println(\"this.value(before filter):\"+this.value); myInterface1.filter(employee); System.out.println(\"this.value(after filter):\"+this.value); } 打印结果： resultIC(this):Inner class value333 resultIC(normal):Inner class value333 this.value(before filter):Enclosing scope value resultLambda(normal):Lambda value333 resultLambda(this):Enclosing scope value333 this.value(after filter):show 多使用方法引用， 在Lambda表达式中 a -\u003e a.toLowerCase()和String::toLowerCase都能起到相同的作用，但两者相比，后者通常可读性更高并且代码会简短。 尽量避免在Lambda的方法体中使用{}代码块： 优先使用 Foo foo = parameter -\u003e buildString(parameter); private String buildString(String parameter) { String result = \"Something \" + parameter; //many lines of code return result; } 而不是 Foo foo = parameter -\u003e { String result = \"Something \" + parameter; //many lines of code return result; }; lambda语法 lambda表达式的语法主要可以参考github on java8\njava8四大内置核心函数式接口 消费型接口(Consumer) 消费型接口源码：\n/** * Represents an operation that accepts a single input argument and returns no * result. Unlike most other functional interfaces, {@code Consumer} is expected * to operate via side-effects. * * This is a functional interface * whose functional method is {@link #accept(Object)}. * * @param the type of the input to the operation * * @since 1.8 */ @FunctionalInterface public interface Consumer\u003cT\u003e { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); } 从上述注释中可以看出，消费型接口就是接收一个参数，然后利用这个参数完成一系列操作。消费型接口使用：\npublic void happy(double money, Consumer\u003cDouble\u003e consumer){ consumer.accept(money); } @Test public void test1(){ happy(10, (m)-\u003e System.out.println(m)); // 打印：10.0 } @Test public void test5(){ // 与使用lambda表达式的效果相同 happy(10, new Consumer\u003cDouble\u003e() { @Override public void accept(Double aDouble) { System.out.println(aDouble); } }); } 我们必须有一个方法A调用了消费型接口的accept方法，然后运行的时候调用方法A并传入一个消费者对象（可以通过匿名内部类完成），使用lambda则是简化了这段代码。\n供给型接口(Supplier) 供给型接口源码：\n/** * Represents a supplier of results. * * There is no requirement that a new or distinct result be returned each * time the supplier is invoked. * * This is a functional interface * whose functional method is {@link #get()}. * * @param the type of results supplied by this supplier * * @since 1.8 */ @FunctionalInterface public interface Supplier\u003cT\u003e { /** * Gets a result. * * @return a result */ T get(); } 供给型接口在get方法完成一系列操作后返回一个结果。供给型接口使用：\npublic List\u003cInteger\u003e getNumList(int length, Supplier\u003cInteger\u003e integerSupplier){ List\u003cInteger\u003e list = new ArrayList\u003c\u003e(length); for(int i = 0; i \u003c length; i++){ list.add(integerSupplier.get()); } return list; } @Test public void test2(){ List\u003cInteger\u003e list = getNumList(10, ()-\u003e(int)(Math.random()*100)); for(Integer in:list){ System.out.print(in + \" \"); } // 打印：41 13 90 13 23 54 69 98 22 25 } 和消费者接口一样，必有有一个方法A调用供给型接口中的get方法，然后调用这个方法A并提供一个供给型接口参数。\n函数型接口(Function) 函数型接口源码：\n/** * Represents a function that accepts one argument and produces a result. * * This is a functional interface * whose functional method is {@link #apply(Object)}. * * @param the type of the input to the function * @param the type of the result of the function * * @since 1.8 */ @FunctionalInterface public interface Function\u003cT, R\u003e { /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); } 函数型接口使用：\n@Test public void test3(){ System.out.println(strHandler(\"test\", (s)-\u003es.toUpperCase())); // 打印：TEST } public String strHandler(String str, Function\u003cString, String\u003e function){ return function.apply(str); } 断言型接口(Predicate) 断言型接口源码：\n/** * Represents a predicate (boolean-valued function) of one argument. * * This is a functional interface * whose functional method is {@link #test(Object)}. * * @param the type of the input to the predicate * * @since 1.8 */ @FunctionalInterface public interface Predicate\u003cT\u003e { /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return {@code true} if the input argument matches the predicate, * otherwise {@code false} */ boolean test(T t); } 断言型接口使用：\n@Test public void test4(){ List\u003cString\u003e list = Arrays.asList(\"Hello\", \"Lambda\", \"Go\", \"java\"); list = filterStr(list, (s)-\u003es.contains(\"o\")); for(String str:list){ System.out.print(str+\" \"); } // 打印：Hello Go } public List\u003cString\u003e filterStr(List\u003cString\u003e list, Predicate\u003cString\u003e predicate){ List\u003cString\u003e stringList = new ArrayList\u003c\u003e(16); for(String str: list){ if(predicate.test(str)){ stringList.add(str); } } return stringList; } 方法引用 什么是方法引用 若lambda体中的内容已经有方法已经实现了，那么就可以使用方法引用\n其实方法引用只是在lambda的基础上进一步简化编程的繁重工作，上面这句话就很好地说明了这一点，在使用lambda的过程中，也许我们会自己实现所需要的方法，但是如果已经有实现好的方法时，我们直接调用就好了，此时java就使用一种叫做方法引用的东西来简化调用的代码。使用方法引用主要有如下形式：\n引用静态方法\tClass::staticMethodName 引用某个对象的实例方法\tobject::instanceMethodName 引用某个类型的任意对象的实例方法\ttype::methodName 引用构造方法\tClassName::new 引用某个对象的实例方法 废话不多说，直接看代码：\n@Test public void test1(){ // 使用lambda PrintStream ps = System.out; Consumer\u003cString\u003e con = (x)-\u003eps.println(x); con.accept(\"haha\"); // 使用方法引用（对象::实例方法名） PrintStream ps1 = System.out; Consumer\u003cString\u003e con1 = ps::println; con1.accept(\"dd\"); Consumer\u003cString\u003e con2 = System.out::println; con2.accept(\"iop\"); /** * 打印结果： * haha * dd * iop */ } 上面的代码就展示了从lambda到方法引用的改变过程。当然，这里只是引用某个对象的实例方法。接下来进行一点改变：\n@Test public void test2(){ Employee employee = new Employee(\"李四\",33,24); Supplier\u003cString\u003e supplier = ()-\u003e employee.getName(); System.out.println(supplier.get()); // 对象::实例方法名 Supplier\u003cInteger\u003e supplier1 = employee::getAge; System.out.println(supplier1.get()); /** * 打印结果： * 李四 * 33 */ } 上面的test2()使用供应者接口，通过供应者接口拿到一个Integer，再输出到cmd，使用的还是 **对象::实例方法名 **。\n引用静态方法 @Test public void test3(){ Comparator\u003cInteger\u003e comparator = (x,y)-\u003eInteger.compare(x,y); // 类名::静态方法名 Comparator\u003cInteger\u003e comparator1 = Integer::compare; System.out.println(comparator.compare(10,11)); System.out.println(comparator1.compare(10,11)); /** * 打印结果： * -1 * -1 */ } 上面的test3()是通过 Integer::compare 来生成一个Comparator的实例，再调用这个实例的compare方法来获取比较的结果，并将其输出到打印台。\n引用某个类型的任意对象的实例方法 这个引用讲道理我还不会用，主要是看到网上有人说有这个，自己对这些的研究还不够，暂时先写到这里，后面有机会再来更新一下。\n构造器引用 构造器引用，顾名思义，其实就是通过类名::new来获取一个引用，过程中使用了构造器。\n@FunctionalInterface // 取名这么随意主要是测试了一些今天看到的泛型使用时泛型的名称随意使用 interface MyFunction\u003cT,U,R,J\u003e{ J apply(T t,U u,R r); } @Test public void test5(){ Supplier\u003cEmployee\u003e supplier = ()-\u003enew Employee(\"dd\",22,33); System.out.println(supplier.get()); // 其中new使用的Employee构造器与函数式接口中传入的相同，如下， // Supplier只是说明要获取一个Employee对象，但是没有传入参数，则调用的为无参构造器 Supplier\u003cEmployee\u003e supplier1 = Employee::new; System.out.println(supplier1.get()); System.out.println(\"-------------\"); // Function function = Employee::new; // 由于使用了lombok，这里就不能这样写了，得传入三个参数，然后返回一个Employee // 于是自定义了一个函数式接口，传入三个参数，返回一个值（这里返回Employee） MyFunction\u003cString, Integer, Integer, Employee\u003e function = Employee::new; System.out.println(function.apply(\"dd\",33,900)); /** * 打印结果： * Employee(name=dd, age=22, salary=33) * Employee(name=null, age=0, salary=0) * ------------- * Employee(name=dd, age=33, salary=900) */ } 其实很多在上面代码中的注释中已经写清楚了，这里就不再赘述。这里还有学到的一个例子，如下\n@Test public void test6(){ Function\u003cInteger, String[]\u003e function = (x)-\u003enew String[x]; String[] strings = function.apply(10); System.out.println(strings.length); Function\u003cInteger, Integer[]\u003e function1 = Integer[]::new; System.out.println(function1.apply(20).length); /** * 打印结果： * 10 * 20 */ } 这个test中使用的是Integer[]::new，而不是普通的类名::new，所以我觉得还是有必要拿出来看看的，以后使用的时候可以参考下。\n总结 函数式编程就和vim一样，是一个熟能生巧的东西，结合Stream可以极大地方面编程，所以以后还是要多练多使用。\n","wordCount":"3871","inLanguage":"en","datePublished":"2023-02-11T00:32:19+08:00","dateModified":"2024-03-21T00:57:04+08:00","author":{"@type":"Person","name":"luolin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8Clambda/"},"publisher":{"@type":"Organization","name":"luolin1024","logo":{"@type":"ImageObject","url":"https://luolin1024.github.io/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luolin1024.github.io accesskey=h title="luolin的博客 (Alt + H)">luolin的博客</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://luolin1024.github.io/posts title=📚文章><span>📚文章</span></a></li><li><a href=https://luolin1024.github.io/archives/ title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luolin1024.github.io/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luolin1024.github.io/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luolin1024.github.io/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luolin1024.github.io/links title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://luolin1024.github.io>Home</a>&nbsp;»&nbsp;<a href=https://luolin1024.github.io/blog_prepublish/>Blog_prepublishes</a></div><h1 class="post-title entry-hint-parent">Java8 函数式编程和Lambda</h1><div class=post-meta><span title='2023-02-11 00:32:19 +0800 +0800'>2023-02-11</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;3871 words&nbsp;·&nbsp;luolin
本文总阅读量 <span id=umami_value_page_pv></span> 次
本文总访客量 <span id=umami_value_page_uv></span> 人</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#lambda aria-label=lambda>lambda</a><ul><li><a href=#%e5%88%9d%e8%af%86lambda%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=初识lambda表达式>初识lambda表达式</a><ul><li><a href=#%e4%bc%98%e5%8c%96%e4%b8%80%e4%bd%bf%e7%94%a8%e7%ad%96%e7%95%a5%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f aria-label=优化一、使用策略设计模式>优化一、使用策略设计模式</a><ul><li><a href=#%e8%87%aa%e5%b7%b1%e6%96%b0%e5%bb%ba%e5%ae%9e%e7%8e%b0%e7%b1%bb%e6%9d%a5%e8%bf%87%e6%bb%a4%e5%91%98%e5%b7%a5%e5%8a%9f%e8%83%bd aria-label=自己新建实现类来过滤员工功能>自己新建实现类来过滤员工功能</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%86%85%e9%83%a8%e5%8c%bf%e5%90%8d%e7%b1%bb%e6%9d%a5%e5%ae%9e%e7%8e%b0%e8%bf%87%e6%bb%a4%e5%91%98%e5%b7%a5%e5%8a%9f%e8%83%bd aria-label=使用内部匿名类来实现过滤员工功能>使用内部匿名类来实现过滤员工功能</a></li></ul></li><li><a href=#%e4%bc%98%e5%8c%96%e4%ba%8c%e4%bd%bf%e7%94%a8lambda%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=优化二、使用lambda表达式>优化二、使用lambda表达式</a></li></ul></li><li><a href=#lambda%e5%8e%9f%e7%90%86 aria-label=lambda原理>lambda原理</a></li><li><a href=#lambda%e8%af%ad%e6%b3%95 aria-label=lambda语法>lambda语法</a></li><li><a href=#java8%e5%9b%9b%e5%a4%a7%e5%86%85%e7%bd%ae%e6%a0%b8%e5%bf%83%e5%87%bd%e6%95%b0%e5%bc%8f%e6%8e%a5%e5%8f%a3 aria-label=java8四大内置核心函数式接口>java8四大内置核心函数式接口</a><ul><li><a href=#%e6%b6%88%e8%b4%b9%e5%9e%8b%e6%8e%a5%e5%8f%a3consumer aria-label=消费型接口(Consumer)>消费型接口(Consumer)</a></li><li><a href=#%e4%be%9b%e7%bb%99%e5%9e%8b%e6%8e%a5%e5%8f%a3supplier aria-label=供给型接口(Supplier)>供给型接口(Supplier)</a></li><li><a href=#%e5%87%bd%e6%95%b0%e5%9e%8b%e6%8e%a5%e5%8f%a3function aria-label=函数型接口(Function)>函数型接口(Function)</a></li><li><a href=#%e6%96%ad%e8%a8%80%e5%9e%8b%e6%8e%a5%e5%8f%a3predicate aria-label=断言型接口(Predicate)>断言型接口(Predicate)</a></li></ul></li></ul></li><li><a href=#%e6%96%b9%e6%b3%95%e5%bc%95%e7%94%a8 aria-label=方法引用>方法引用</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e6%96%b9%e6%b3%95%e5%bc%95%e7%94%a8 aria-label=什么是方法引用>什么是方法引用</a></li><li><a href=#%e5%bc%95%e7%94%a8%e6%9f%90%e4%b8%aa%e5%af%b9%e8%b1%a1%e7%9a%84%e5%ae%9e%e4%be%8b%e6%96%b9%e6%b3%95 aria-label=引用某个对象的实例方法>引用某个对象的实例方法</a></li><li><a href=#%e5%bc%95%e7%94%a8%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95 aria-label=引用静态方法>引用静态方法</a></li><li><a href=#%e5%bc%95%e7%94%a8%e6%9f%90%e4%b8%aa%e7%b1%bb%e5%9e%8b%e7%9a%84%e4%bb%bb%e6%84%8f%e5%af%b9%e8%b1%a1%e7%9a%84%e5%ae%9e%e4%be%8b%e6%96%b9%e6%b3%95 aria-label=引用某个类型的任意对象的实例方法>引用某个类型的任意对象的实例方法</a></li><li><a href=#%e6%9e%84%e9%80%a0%e5%99%a8%e5%bc%95%e7%94%a8 aria-label=构造器引用>构造器引用</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=lambda>lambda<a hidden class=anchor aria-hidden=true href=#lambda>#</a></h2><h3 id=初识lambda表达式>初识lambda表达式<a hidden class=anchor aria-hidden=true href=#初识lambda表达式>#</a></h3><p>一个简单的方法，比较两个Integer：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>Test1</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Comparator</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>com</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Comparator</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=nd>@Override</span>
</span></span><span class=line><span class=cl>		<span class=kd>public</span> <span class=kt>int</span> <span class=nf>compare</span><span class=o>(</span><span class=n>Integer</span> <span class=n>o1</span><span class=o>,</span> <span class=n>Integer</span> <span class=n>o2</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=n>Integer</span><span class=o>.</span><span class=na>compare</span><span class=o>(</span><span class=n>o1</span><span class=o>,</span> <span class=n>o2</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span>
</span></span><span class=line><span class=cl>	<span class=o>};</span>
</span></span><span class=line><span class=cl>	<span class=n>TreeSet</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>treeSet</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TreeSet</span><span class=o>&lt;&gt;(</span><span class=n>com</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>下面的这个方法与上面的方法效果相同：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>Test2</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Comparator</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>com</span> <span class=o>=</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>y</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Integer</span><span class=o>.</span><span class=na>compare</span><span class=o>(</span><span class=n>x</span><span class=o>,</span> <span class=n>y</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=n>TreeSet</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>treeSet</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TreeSet</span><span class=o>&lt;&gt;(</span><span class=n>com</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>从上面就可以看出lambda表达式可以极大地简化代码量现在有一个需求，找出所有年龄大于35的员工,Employee的实体类属性如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>String</span> <span class=n>name</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>age</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>salary</span><span class=o>;</span>
</span></span></code></pre></div><p>创建一个List保存数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>employees</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span>
</span></span><span class=line><span class=cl>		<span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;张三&#34;</span><span class=o>,</span> <span class=mi>11</span><span class=o>,</span> <span class=mi>9000</span><span class=o>),</span>
</span></span><span class=line><span class=cl>		<span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;李四&#34;</span><span class=o>,</span> <span class=mi>33</span><span class=o>,</span> <span class=mi>3000</span><span class=o>),</span>
</span></span><span class=line><span class=cl>		<span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;王五&#34;</span><span class=o>,</span> <span class=mi>44</span><span class=o>,</span> <span class=mi>4000</span><span class=o>),</span>
</span></span><span class=line><span class=cl>		<span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;p8&#34;</span><span class=o>,</span> <span class=mi>55</span><span class=o>,</span> <span class=mi>2000</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>);</span>
</span></span></code></pre></div><p>一开始，我们也许会选择一种最简单的方法去实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=nf>Test3</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>List</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=o>(</span><span class=n>Employee</span> <span class=n>employee</span> <span class=o>:</span> <span class=n>employees</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=o>(</span><span class=n>employee</span><span class=o>.</span><span class=na>age</span> <span class=o>&gt;</span> <span class=mi>35</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>employee</span><span class=o>)</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>list</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h4 id=优化一使用策略设计模式>优化一、使用策略设计模式<a hidden class=anchor aria-hidden=true href=#优化一使用策略设计模式>#</a></h4><h5 id=自己新建实现类来过滤员工功能>自己新建实现类来过滤员工功能<a hidden class=anchor aria-hidden=true href=#自己新建实现类来过滤员工功能>#</a></h5><p>然后有了一个新的需求，找出所有员工中工资高于3500的员工，此时就需要加方法了，然后也许还会有别的需求（姓李的员工）等，我们不可能每次加需求都要加方法，于是这时候可以采用策略设计模式，设计一个接口MyInterface,里面声明一个用于处理过滤员工的方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>MyInterface</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>    
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=nf>filter</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>编写一个专门用于过滤员工的方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 用于过滤 Employee
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param list
</span></span></span><span class=line><span class=cl><span class=cm> * @param myInterface
</span></span></span><span class=line><span class=cl><span class=cm> * @return
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=nf>filterEmployees</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>,</span> <span class=n>MyInterface</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>myInterface</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>emp</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=n>Employee</span> <span class=n>employee</span> <span class=o>:</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>myInterface</span><span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>employee</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>emp</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>employee</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>emp</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>之后如果需要使用员工过滤的方法时，调用filterEmployees方法时传入MyInterface的具体实现类，这个实现类中重写好所需要的filter方法。</p><h5 id=使用内部匿名类来实现过滤员工功能>使用内部匿名类来实现过滤员工功能<a hidden class=anchor aria-hidden=true href=#使用内部匿名类来实现过滤员工功能>#</a></h5><p>我们此时在调用的方法中就是传入一个匿名内部类，重写好我们所需要的方法即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test4</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=n>filterEmployees</span><span class=o>(</span><span class=n>employees</span><span class=o>,</span> <span class=k>new</span> <span class=n>MyInterface</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>filter</span><span class=o>(</span><span class=n>Employee</span> <span class=n>employee</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=o>(</span><span class=n>employee</span><span class=o>.</span><span class=na>age</span> <span class=o>&gt;</span> <span class=mi>22</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>});</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=n>Employee</span> <span class=n>employee</span> <span class=o>:</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>employee</span><span class=o>.</span><span class=na>name</span> <span class=o>+</span> <span class=s>&#34; &#34;</span> <span class=o>+</span> <span class=n>employee</span><span class=o>.</span><span class=na>age</span> <span class=o>+</span> <span class=s>&#34; &#34;</span> <span class=o>+</span> <span class=n>employee</span><span class=o>.</span><span class=na>salary</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h4 id=优化二使用lambda表达式>优化二、使用lambda表达式<a hidden class=anchor aria-hidden=true href=#优化二使用lambda表达式>#</a></h4><p>lambda表达式其实就是简化了使用匿名内部类的写法繁琐</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test5</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=n>filterEmployees</span><span class=o>(</span><span class=n>employees</span><span class=o>,</span> <span class=o>(</span><span class=n>employee</span> <span class=o>-&gt;</span> <span class=n>employee</span><span class=o>.</span><span class=na>age</span> <span class=o>&gt;</span> <span class=mi>22</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=n>Employee</span> <span class=n>employee</span> <span class=o>:</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>employee</span><span class=o>.</span><span class=na>name</span> <span class=o>+</span> <span class=s>&#34; &#34;</span> <span class=o>+</span> <span class=n>employee</span><span class=o>.</span><span class=na>age</span> <span class=o>+</span> <span class=s>&#34; &#34;</span> <span class=o>+</span> <span class=n>employee</span><span class=o>.</span><span class=na>salary</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=lambda原理>lambda原理<a hidden class=anchor aria-hidden=true href=#lambda原理>#</a></h3><p>在讲almbda原理之前先说下函数式接口FunctionalInterface，FunctionalInterface就是接口中只有一个抽象方法的接口，此时可以使用注解@FunctionalInterface，如果注解的接口内部有多个抽象方法，编译器会报错。那么这和lambda有什么关系呢，思考一下，如果使用lambda来替代一个匿名内部类的写法，我们使用lambda的时候是没有指明使用实现接口的哪个方法的，也就是说如果接口内有多个抽象方法，编译器就不知道lambda想要重写哪个方法，这个时候自然会报错。注意事项：</p><ol><li>保持Lambda表达式简短和一目了然，过长的Lambda表达式通常是危险的，因为代码越长越难以读懂，意图看起来也不明，并且代码也难以复用，测试难度也大。</li><li>使用@FunctionalInterface注解，否则他人修改了函数式接口后使用lambda的地方就用不了了。</li><li>不要在Lambda表达中执行有"副作用"的操作，&ldquo;副作用"是严重违背函数式编程的设计原则，比如在forEach操作里面操作外面的某个List或者设置某个Map这其实是不对的。</li><li>不要把Lambda表达式和匿名内部类同等对待。lambda和匿名内部类是有区别的，主要区别在于匿名内部类中的this和lambda中的this指代的是不同的实例。匿名内部类中的this指向当前匿名内部类的实例（且匿名内部类中的this只能指向内部类的实例，不能指向所在类的实例），而lambda中的this指向所在类的实例，测试如下：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=n>String</span> <span class=n>value</span> <span class=o>=</span> <span class=s>&#34;Enclosing scope value&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>Test6</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>333</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>MyInterface</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>myInterface</span> <span class=o>=</span> <span class=k>new</span> <span class=n>MyInterface</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>value</span> <span class=o>=</span> <span class=s>&#34;Inner class value&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>filter</span><span class=o>(</span><span class=n>Employee</span> <span class=n>employee</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;resultIC(this):&#34;</span><span class=o>+</span><span class=k>this</span><span class=o>.</span><span class=na>value</span><span class=o>+</span><span class=n>num</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;resultIC(normal):&#34;</span><span class=o>+</span><span class=n>value</span><span class=o>+</span><span class=n>num</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Employee</span> <span class=n>employee</span> <span class=o>=</span> <span class=n>employees</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=mi>0</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>myInterface</span><span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>employee</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>MyInterface</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>myInterface1</span> <span class=o>=</span> <span class=n>employee1</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>value</span> <span class=o>=</span> <span class=s>&#34;Lambda value&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;resultLambda(normal):&#34;</span><span class=o>+</span><span class=n>value</span><span class=o>+</span><span class=n>num</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;resultLambda(this):&#34;</span><span class=o>+</span><span class=k>this</span><span class=o>.</span><span class=na>value</span><span class=o>+</span><span class=n>num</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=s>&#34;show&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>};</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;this.value(before filter):&#34;</span><span class=o>+</span><span class=k>this</span><span class=o>.</span><span class=na>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>myInterface1</span><span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>employee</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;this.value(after filter):&#34;</span><span class=o>+</span><span class=k>this</span><span class=o>.</span><span class=na>value</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=err>打印结果：</span>
</span></span><span class=line><span class=cl><span class=n>resultIC</span><span class=o>(</span><span class=k>this</span><span class=o>):</span><span class=n>Inner</span> <span class=kd>class</span> <span class=nc>value333</span>
</span></span><span class=line><span class=cl><span class=nf>resultIC</span><span class=o>(</span><span class=n>normal</span><span class=o>):</span><span class=n>Inner</span> <span class=kd>class</span> <span class=nc>value333</span>
</span></span><span class=line><span class=cl><span class=k>this</span><span class=o>.</span><span class=na>value</span><span class=o>(</span><span class=n>before</span> <span class=n>filter</span><span class=o>):</span><span class=n>Enclosing</span> <span class=n>scope</span> <span class=n>value</span>
</span></span><span class=line><span class=cl><span class=nf>resultLambda</span><span class=o>(</span><span class=n>normal</span><span class=o>):</span><span class=n>Lambda</span> <span class=n>value333</span>
</span></span><span class=line><span class=cl><span class=nf>resultLambda</span><span class=o>(</span><span class=k>this</span><span class=o>):</span><span class=n>Enclosing</span> <span class=n>scope</span> <span class=n>value333</span>
</span></span><span class=line><span class=cl><span class=k>this</span><span class=o>.</span><span class=na>value</span><span class=o>(</span><span class=n>after</span> <span class=n>filter</span><span class=o>):</span><span class=n>show</span>
</span></span></code></pre></div><ol start=5><li>多使用方法引用， 在Lambda表达式中 a -> a.toLowerCase()和String::toLowerCase都能起到相同的作用，但两者相比，后者通常可读性更高并且代码会简短。</li><li>尽量避免在Lambda的方法体中使用{}代码块：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=err>优先使用</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span> <span class=n>foo</span> <span class=o>=</span> <span class=n>parameter</span> <span class=o>-&gt;</span> <span class=n>buildString</span><span class=o>(</span><span class=n>parameter</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>String</span> <span class=nf>buildString</span><span class=o>(</span><span class=n>String</span> <span class=n>parameter</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>result</span> <span class=o>=</span> <span class=s>&#34;Something &#34;</span> <span class=o>+</span> <span class=n>parameter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//many lines of code
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=err>而不是</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span> <span class=n>foo</span> <span class=o>=</span> <span class=n>parameter</span> <span class=o>-&gt;</span> <span class=o>{</span> <span class=n>String</span> <span class=n>result</span> <span class=o>=</span> <span class=s>&#34;Something &#34;</span> <span class=o>+</span> <span class=n>parameter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//many lines of code
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>};</span>
</span></span></code></pre></div><h3 id=lambda语法>lambda语法<a hidden class=anchor aria-hidden=true href=#lambda语法>#</a></h3><p>lambda表达式的语法主要可以参考<a href=https://github.com/LingCoder/OnJava8/blob/master/docs/book/13-Functional-Programming.md>github on java8</a></p><h3 id=java8四大内置核心函数式接口>java8四大内置核心函数式接口<a hidden class=anchor aria-hidden=true href=#java8四大内置核心函数式接口>#</a></h3><h4 id=消费型接口consumer>消费型接口(Consumer)<a hidden class=anchor aria-hidden=true href=#消费型接口consumer>#</a></h4><p>消费型接口源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Represents an operation that accepts a single input argument and returns no
</span></span></span><span class=line><span class=cl><span class=cm> * result. Unlike most other functional interfaces, {@code Consumer} is expected
</span></span></span><span class=line><span class=cl><span class=cm> * to operate via side-effects.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;p&gt;This is a &lt;a href=&#34;package-summary.html&#34;&gt;functional interface&lt;/a&gt;
</span></span></span><span class=line><span class=cl><span class=cm> * whose functional method is {@link #accept(Object)}.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param &lt;T&gt; the type of the input to the operation
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @since 1.8
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Consumer</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Performs this operation on the given argument.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @param t the input argument
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>accept</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>从上述注释中可以看出，消费型接口就是接收一个参数，然后利用这个参数完成一系列操作。消费型接口使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>happy</span><span class=o>(</span><span class=kt>double</span> <span class=n>money</span><span class=o>,</span> <span class=n>Consumer</span><span class=o>&lt;</span><span class=n>Double</span><span class=o>&gt;</span> <span class=n>consumer</span><span class=o>){</span>
</span></span><span class=line><span class=cl>    <span class=n>consumer</span><span class=o>.</span><span class=na>accept</span><span class=o>(</span><span class=n>money</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test1</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>happy</span><span class=o>(</span><span class=mi>10</span><span class=o>,</span> <span class=o>(</span><span class=n>m</span><span class=o>)-&gt;</span> <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>m</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 打印：10.0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test5</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 与使用lambda表达式的效果相同
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>happy</span><span class=o>(</span><span class=mi>10</span><span class=o>,</span> <span class=k>new</span> <span class=n>Consumer</span><span class=o>&lt;</span><span class=n>Double</span><span class=o>&gt;()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>void</span> <span class=nf>accept</span><span class=o>(</span><span class=n>Double</span> <span class=n>aDouble</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>aDouble</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>});</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>我们必须有一个方法A调用了消费型接口的<code>accept</code>方法，然后运行的时候调用方法A并传入一个消费者对象（可以通过匿名内部类完成），使用lambda则是简化了这段代码。</p><h4 id=供给型接口supplier>供给型接口(Supplier)<a hidden class=anchor aria-hidden=true href=#供给型接口supplier>#</a></h4><p>供给型接口源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Represents a supplier of results.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;p&gt;There is no requirement that a new or distinct result be returned each
</span></span></span><span class=line><span class=cl><span class=cm> * time the supplier is invoked.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;p&gt;This is a &lt;a href=&#34;package-summary.html&#34;&gt;functional interface&lt;/a&gt;
</span></span></span><span class=line><span class=cl><span class=cm> * whose functional method is {@link #get()}.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param &lt;T&gt; the type of results supplied by this supplier
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @since 1.8
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Supplier</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Gets a result.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @return a result
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=nf>get</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>供给型接口在<code>get</code>方法完成一系列操作后返回一个结果。供给型接口使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>getNumList</span><span class=o>(</span><span class=kt>int</span> <span class=n>length</span><span class=o>,</span> <span class=n>Supplier</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>integerSupplier</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;(</span><span class=n>length</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++){</span>
</span></span><span class=line><span class=cl>            <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>integerSupplier</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>list</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Test</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>test2</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=n>getNumList</span><span class=o>(</span><span class=mi>10</span><span class=o>,</span> <span class=o>()-&gt;(</span><span class=kt>int</span><span class=o>)(</span><span class=n>Math</span><span class=o>.</span><span class=na>random</span><span class=o>()*</span><span class=mi>100</span><span class=o>));</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=o>(</span><span class=n>Integer</span> <span class=n>in</span><span class=o>:</span><span class=n>list</span><span class=o>){</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=n>in</span> <span class=o>+</span> <span class=s>&#34; &#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 打印：41 13 90 13 23 54 69 98 22 25
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span></code></pre></div><p>和消费者接口一样，必有有一个方法A调用供给型接口中的<code>get</code>方法，然后调用这个方法A并提供一个供给型接口参数。</p><h4 id=函数型接口function>函数型接口(Function)<a hidden class=anchor aria-hidden=true href=#函数型接口function>#</a></h4><p>函数型接口源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Represents a function that accepts one argument and produces a result.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;p&gt;This is a &lt;a href=&#34;package-summary.html&#34;&gt;functional interface&lt;/a&gt;
</span></span></span><span class=line><span class=cl><span class=cm> * whose functional method is {@link #apply(Object)}.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param &lt;T&gt; the type of the input to the function
</span></span></span><span class=line><span class=cl><span class=cm> * @param &lt;R&gt; the type of the result of the function
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @since 1.8
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Function</span><span class=o>&lt;</span><span class=n>T</span><span class=o>,</span> <span class=n>R</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Applies this function to the given argument.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @param t the function argument
</span></span></span><span class=line><span class=cl><span class=cm>     * @return the function result
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>R</span> <span class=nf>apply</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>函数型接口使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test3</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>strHandler</span><span class=o>(</span><span class=s>&#34;test&#34;</span><span class=o>,</span> <span class=o>(</span><span class=n>s</span><span class=o>)-&gt;</span><span class=n>s</span><span class=o>.</span><span class=na>toUpperCase</span><span class=o>()));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 打印：TEST
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>String</span> <span class=nf>strHandler</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>,</span> <span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>function</span><span class=o>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>function</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=n>str</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h4 id=断言型接口predicate>断言型接口(Predicate)<a hidden class=anchor aria-hidden=true href=#断言型接口predicate>#</a></h4><p>断言型接口源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Represents a predicate (boolean-valued function) of one argument.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;p&gt;This is a &lt;a href=&#34;package-summary.html&#34;&gt;functional interface&lt;/a&gt;
</span></span></span><span class=line><span class=cl><span class=cm> * whose functional method is {@link #test(Object)}.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @param &lt;T&gt; the type of the input to the predicate
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @since 1.8
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Predicate</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Evaluates this predicate on the given argument.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @param t the input argument
</span></span></span><span class=line><span class=cl><span class=cm>     * @return {@code true} if the input argument matches the predicate,
</span></span></span><span class=line><span class=cl><span class=cm>     * otherwise {@code false}
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=nf>test</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>断言型接口使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test4</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=s>&#34;Hello&#34;</span><span class=o>,</span> <span class=s>&#34;Lambda&#34;</span><span class=o>,</span> <span class=s>&#34;Go&#34;</span><span class=o>,</span> <span class=s>&#34;java&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span> <span class=o>=</span> <span class=n>filterStr</span><span class=o>(</span><span class=n>list</span><span class=o>,</span> <span class=o>(</span><span class=n>s</span><span class=o>)-&gt;</span><span class=n>s</span><span class=o>.</span><span class=na>contains</span><span class=o>(</span><span class=s>&#34;o&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>:</span><span class=n>list</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=n>str</span><span class=o>+</span><span class=s>&#34; &#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 打印：Hello Go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>filterStr</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>,</span> <span class=n>Predicate</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>predicate</span><span class=o>){</span>
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>stringList</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;(</span><span class=mi>16</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>:</span> <span class=n>list</span><span class=o>){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=o>(</span><span class=n>predicate</span><span class=o>.</span><span class=na>test</span><span class=o>(</span><span class=n>str</span><span class=o>)){</span>
</span></span><span class=line><span class=cl>            <span class=n>stringList</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>str</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>stringList</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=方法引用>方法引用<a hidden class=anchor aria-hidden=true href=#方法引用>#</a></h2><h3 id=什么是方法引用>什么是方法引用<a hidden class=anchor aria-hidden=true href=#什么是方法引用>#</a></h3><blockquote><p>若lambda体中的内容已经有方法已经实现了，那么就可以使用方法引用</p></blockquote><p>其实方法引用只是在lambda的基础上进一步简化编程的繁重工作，上面这句话就很好地说明了这一点，在使用lambda的过程中，也许我们会自己实现所需要的方法，但是如果已经有实现好的方法时，我们直接调用就好了，此时java就使用一种叫做方法引用的东西来简化调用的代码。使用方法引用主要有如下形式：</p><ul><li>引用静态方法 <code>Class::staticMethodName</code></li><li>引用某个对象的实例方法 <code>object::instanceMethodName</code></li><li>引用某个类型的任意对象的实例方法 <code>type::methodName</code></li><li>引用构造方法 <code>ClassName::new</code></li></ul><h3 id=引用某个对象的实例方法>引用某个对象的实例方法<a hidden class=anchor aria-hidden=true href=#引用某个对象的实例方法>#</a></h3><p>废话不多说，直接看代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test1</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用lambda
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PrintStream</span> <span class=n>ps</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Consumer</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>con</span> <span class=o>=</span> <span class=o>(</span><span class=n>x</span><span class=o>)-&gt;</span><span class=n>ps</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>con</span><span class=o>.</span><span class=na>accept</span><span class=o>(</span><span class=s>&#34;haha&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 使用方法引用（对象::实例方法名）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PrintStream</span> <span class=n>ps1</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Consumer</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>con1</span> <span class=o>=</span> <span class=n>ps</span><span class=o>::</span><span class=n>println</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>con1</span><span class=o>.</span><span class=na>accept</span><span class=o>(</span><span class=s>&#34;dd&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Consumer</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>con2</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>println</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>con2</span><span class=o>.</span><span class=na>accept</span><span class=o>(</span><span class=s>&#34;iop&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 打印结果：
</span></span></span><span class=line><span class=cl><span class=cm>     * haha
</span></span></span><span class=line><span class=cl><span class=cm>     * dd
</span></span></span><span class=line><span class=cl><span class=cm>     * iop
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>上面的代码就展示了从lambda到方法引用的改变过程。当然，这里只是引用某个对象的实例方法。接下来进行一点改变：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test2</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Employee</span> <span class=n>employee</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;李四&#34;</span><span class=o>,</span><span class=mi>33</span><span class=o>,</span><span class=mi>24</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Supplier</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>supplier</span> <span class=o>=</span> <span class=o>()-&gt;</span> <span class=n>employee</span><span class=o>.</span><span class=na>getName</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>supplier</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 对象::实例方法名
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Supplier</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>supplier1</span> <span class=o>=</span> <span class=n>employee</span><span class=o>::</span><span class=n>getAge</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>supplier1</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 打印结果：
</span></span></span><span class=line><span class=cl><span class=cm>     * 李四
</span></span></span><span class=line><span class=cl><span class=cm>     * 33
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>上面的test2()使用供应者接口，通过供应者接口拿到一个Integer，再输出到cmd，使用的还是 **对象::实例方法名 **。</p><h3 id=引用静态方法>引用静态方法<a hidden class=anchor aria-hidden=true href=#引用静态方法>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test3</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Comparator</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>comparator</span> <span class=o>=</span> <span class=o>(</span><span class=n>x</span><span class=o>,</span><span class=n>y</span><span class=o>)-&gt;</span><span class=n>Integer</span><span class=o>.</span><span class=na>compare</span><span class=o>(</span><span class=n>x</span><span class=o>,</span><span class=n>y</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 类名::静态方法名
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Comparator</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>comparator1</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>::</span><span class=n>compare</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>comparator</span><span class=o>.</span><span class=na>compare</span><span class=o>(</span><span class=mi>10</span><span class=o>,</span><span class=mi>11</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>comparator1</span><span class=o>.</span><span class=na>compare</span><span class=o>(</span><span class=mi>10</span><span class=o>,</span><span class=mi>11</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 打印结果：
</span></span></span><span class=line><span class=cl><span class=cm>     * -1
</span></span></span><span class=line><span class=cl><span class=cm>     * -1
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>上面的test3()是通过 <code>Integer::compare</code> 来生成一个Comparator的实例，再调用这个实例的compare方法来获取比较的结果，并将其输出到打印台。</p><h3 id=引用某个类型的任意对象的实例方法>引用某个类型的任意对象的实例方法<a hidden class=anchor aria-hidden=true href=#引用某个类型的任意对象的实例方法>#</a></h3><p>这个引用讲道理我还不会用，主要是看到网上有人说有这个，自己对这些的研究还不够，暂时先写到这里，后面有机会再来更新一下。</p><h3 id=构造器引用>构造器引用<a hidden class=anchor aria-hidden=true href=#构造器引用>#</a></h3><p>构造器引用，顾名思义，其实就是通过<code>类名::new</code>来获取一个引用，过程中使用了构造器。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span>
</span></span><span class=line><span class=cl><span class=c1>// 取名这么随意主要是测试了一些今天看到的泛型使用时泛型的名称随意使用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>interface</span> <span class=nc>MyFunction</span><span class=o>&lt;</span><span class=n>T</span><span class=o>,</span><span class=n>U</span><span class=o>,</span><span class=n>R</span><span class=o>,</span><span class=n>J</span><span class=o>&gt;{</span>
</span></span><span class=line><span class=cl>    <span class=n>J</span> <span class=nf>apply</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>,</span><span class=n>U</span> <span class=n>u</span><span class=o>,</span><span class=n>R</span> <span class=n>r</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test5</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Supplier</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>supplier</span> <span class=o>=</span> <span class=o>()-&gt;</span><span class=k>new</span> <span class=n>Employee</span><span class=o>(</span><span class=s>&#34;dd&#34;</span><span class=o>,</span><span class=mi>22</span><span class=o>,</span><span class=mi>33</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>supplier</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 其中new使用的Employee构造器与函数式接口中传入的相同，如下，
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Supplier&lt;Employee&gt;只是说明要获取一个Employee对象，但是没有传入参数，则调用的为无参构造器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Supplier</span><span class=o>&lt;</span><span class=n>Employee</span><span class=o>&gt;</span> <span class=n>supplier1</span> <span class=o>=</span> <span class=n>Employee</span><span class=o>::</span><span class=k>new</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>supplier1</span><span class=o>.</span><span class=na>get</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;-------------&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Function&lt;Integer, Employee&gt; function = Employee::new;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 由于使用了lombok，这里就不能这样写了，得传入三个参数，然后返回一个Employee
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 于是自定义了一个函数式接口，传入三个参数，返回一个值（这里返回Employee）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MyFunction</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>,</span> <span class=n>Employee</span><span class=o>&gt;</span> <span class=n>function</span> <span class=o>=</span> <span class=n>Employee</span><span class=o>::</span><span class=k>new</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>function</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=s>&#34;dd&#34;</span><span class=o>,</span><span class=mi>33</span><span class=o>,</span><span class=mi>900</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 打印结果：
</span></span></span><span class=line><span class=cl><span class=cm>     * Employee(name=dd, age=22, salary=33)
</span></span></span><span class=line><span class=cl><span class=cm>     * Employee(name=null, age=0, salary=0)
</span></span></span><span class=line><span class=cl><span class=cm>     * -------------
</span></span></span><span class=line><span class=cl><span class=cm>     * Employee(name=dd, age=33, salary=900)
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>其实很多在上面代码中的注释中已经写清楚了，这里就不再赘述。这里还有学到的一个例子，如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test6</span><span class=o>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>Function</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>String</span><span class=o>[]&gt;</span> <span class=n>function</span> <span class=o>=</span> <span class=o>(</span><span class=n>x</span><span class=o>)-&gt;</span><span class=k>new</span> <span class=n>String</span><span class=o>[</span><span class=n>x</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span><span class=o>[]</span> <span class=n>strings</span> <span class=o>=</span> <span class=n>function</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=mi>10</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>strings</span><span class=o>.</span><span class=na>length</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Function</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>[]&gt;</span> <span class=n>function1</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>[]::</span><span class=k>new</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>function1</span><span class=o>.</span><span class=na>apply</span><span class=o>(</span><span class=mi>20</span><span class=o>).</span><span class=na>length</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 打印结果：
</span></span></span><span class=line><span class=cl><span class=cm>     * 10
</span></span></span><span class=line><span class=cl><span class=cm>     * 20
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>这个test中使用的是<code>Integer[]::new</code>，而不是普通的<code>类名::new</code>，所以我觉得还是有必要拿出来看看的，以后使用的时候可以参考下。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>函数式编程就和vim一样，是一个熟能生巧的东西，结合Stream可以极大地方面编程，所以以后还是要多练多使用。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://luolin1024.github.io/tags/java/java%E5%9F%BA%E7%A1%80/>Java/Java基础</a></li></ul><nav class=paginav><a class=prev href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java8-stream/><span class=title>« Prev</span><br><span>Java8 Stream</span></a>
<a class=next href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6/><span class=title>Next »</span><br><span>Java传参机制</span></a></nav><div class=related-posts><h2>相关文章</h2><ul><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%93%E5%90%88threadlocal%E7%9A%84%E7%94%A8%E6%B3%95%E5%AE%9E%E4%BE%8B/>Java线程池结合ThreadLocal的用法实例</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/object%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>Object源码分析</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/threadlocal%E5%92%8Cinheritablethreadlocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>ThreadLocal和InheritableThreadLocal源码分析</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java-%E5%8F%8D%E5%B0%84/>Java-反射</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/java8-stream/>Java8 Stream</a></li></ul></div></footer><link rel=stylesheet href=https://unpkg.com/@waline/client@v2/dist/waline.css><div id=waline></div><script type=module>
    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
    const locale = {
        nick: '昵称',
        nickError: '请填写昵称',
        mail: '邮箱',
        mailError: '请填写正确的邮件地址',
        link: '网址',
        optional: '可选',
        placeholder: '仅填写昵称即可发表回复。\n填写邮箱可收到回复提醒。\n评论区支持 Markdown 语法及预览。\n',
        sofa: '来发评论吧~',
        submit: '提交',
        like: '喜欢',
        cancelLike: '取消喜欢',
        reply: '回复',
        cancelReply: '取消回复',
        comment: '评论',
        refresh: '刷新',
        more: '加载更多...',
        preview: '预览',
        emoji: '表情',
        uploadImage: '上传图片',
        seconds: '秒前',
        minutes: '分钟前',
        hours: '小时前',
        days: '天前',
        now: '刚刚',
        uploading: '正在上传',
        login: '管理',
        logout: '退出',
        admin: '博主',
        sticky: '置顶',
        word: '字',
        wordHint: '评论字数应在 $0 到 $1 字之间！\n当前字数：$2',
        anonymous: '匿名',
        level0: '潜水',
        level1: '冒泡',
        level2: '吐槽',
        level3: '活跃',
        level4: '话痨',
        level5: '传说',
        gif: '表情包',
        gifSearchPlaceholder: '搜索表情包',
        profile: '个人资料',
        approved: '通过',
        waiting: '待审核',
        spam: '垃圾',
        unsticky: '取消置顶',
        oldest: '按倒序',
        latest: '按正序',
        hottest: '按热度',
        reactionTitle: '你认为这篇文章怎么样？',
    };
    init({
        
        el: '#waline',
        serverURL: 'https://blogcomments.luolin.online',
        locale,
        emoji: false,     
        search: false,    
        reaction: false,  
        requiredMeta: ['nick'],
        pageSize: 10,
        imageUploader: false,
        copyright: true,
        pageview: true,
        like: false,
    });
</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://luolin1024.github.io>luolin1024</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div>本站总访问量 <span id=umami_value_site_pv></span> 次
本站总访客数 <span id=umami_value_site_uv></span> 人
当前在线访客 <span id=umami_value_active_uv></span> 人</div><a href="https://icp.gov.moe/?keyword=20248618" target=_blank>萌ICP备20248618号</a></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>