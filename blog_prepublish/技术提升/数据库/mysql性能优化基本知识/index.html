<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySql性能优化基本知识 | luolin1024</title><meta name=keywords content="数据库/Mysql,性能优化"><meta name=description content="Mysql分层、存储引擎 常用引擎对比：InnoDB:事务优先(适合高并发操作，使用行锁) MyISAM:性能优先（使用表锁） 可以使用show e"><meta name=author content="luolin"><link rel=canonical href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/><script defer src=https://blogcounter.luolin.us.kg/script.js data-website-id=c8850e2c-16aa-465e-aa6f-5392c9397317></script>
<script src=/js/umami-stats.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luolin1024.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://luolin1024.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://luolin1024.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://luolin1024.github.io/apple-touch-icon.png><link rel=mask-icon href=https://luolin1024.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><html><head><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css><style>body{font-family:lxgw wenkai lite,sans-serif;font-family:lxgw wenkai screen,sans-serif}</style></head></html><meta property="og:title" content="MySql性能优化基本知识"><meta property="og:description" content="Mysql分层、存储引擎 常用引擎对比：InnoDB:事务优先(适合高并发操作，使用行锁) MyISAM:性能优先（使用表锁） 可以使用show e"><meta property="og:type" content="article"><meta property="og:url" content="https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"><meta property="article:section" content="blog_prepublish"><meta property="article:published_time" content="2024-02-21T11:30:51+08:00"><meta property="article:modified_time" content="2024-03-21T00:48:39+08:00"><meta property="og:site_name" content="luolin的博客"><meta name=twitter:card content="summary"><meta name=twitter:title content="MySql性能优化基本知识"><meta name=twitter:description content="Mysql分层、存储引擎 常用引擎对比：InnoDB:事务优先(适合高并发操作，使用行锁) MyISAM:性能优先（使用表锁） 可以使用show e"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog_prepublishes","item":"https://luolin1024.github.io/blog_prepublish/"},{"@type":"ListItem","position":2,"name":"MySql性能优化基本知识","item":"https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySql性能优化基本知识","name":"MySql性能优化基本知识","description":"Mysql分层、存储引擎 常用引擎对比：InnoDB:事务优先(适合高并发操作，使用行锁) MyISAM:性能优先（使用表锁） 可以使用show e","keywords":["数据库/Mysql","性能优化"],"articleBody":"Mysql分层、存储引擎 常用引擎对比：InnoDB:事务优先(适合高并发操作，使用行锁) MyISAM:性能优先（使用表锁）\n可以使用show engines;查看当前使用数据库支持哪些引擎；使用show VARIABLES LIKE '%storage_engine%';正在使用的引擎。\nsql解析过程、索引、B树 sql解析过程 一条sql示例如下：\nSELECT DISTINCT \u003c select_list \u003e FROM \u003c left_table \u003e \u003c join_type \u003e JOIN \u003c right_table \u003e ON \u003c join_condition \u003e WHERE \u003c where_condition \u003e GROUP BY \u003c group_by_list \u003e HAVING \u003c having_condition \u003e ORDER BY \u003c order_by_condition \u003e LIMIT \u003c limit_number \u003e 然而它的执行过程却是：\nFROM \u003cleft_table\u003e ON \u003cjoin_condition\u003e \u003cjoin_type\u003e JOIN \u003cright_table\u003e WHERE \u003cwhere_condition\u003e GROUP BY \u003cgroup_by_list\u003e HAVING \u003chaving_condition\u003e SELECT DISTINCT \u003cselect_list\u003e ORDER BY \u003corder_by_condition\u003e LIMIT \u003climit_number\u003e 索引 索引相当于书的目录，可以帮助Mysql高效获取数据的数据结构，一般使用树、B树、Hash树..完成\n索引的弊端：\n索引本身很大，可以存放在内存/硬盘（通常为硬盘） 索引不是所有情况均适用：少量数据频繁更新的字段很少使用的字段 索引会降低增删改的效率 索引的优势：\n提高查询效率（降低IO使用率） 降低CPU使用率(… order by age desc，因为B树索引本身就是一个排好序的结构，不再需要排序) 索引分类\n主键索引：不能重复。id 不能是null 唯一索引：不能重复。id 可以是null 单值索引：单列，age；一个表可以有多个单值索引,name。 复合索引：多个列构成的索引（相当于二级目录：z:zhao） 创建索引\n方式一：create \u003c索引类型\u003e \u003c索引名\u003e on \u003c表名(字段)\u003e单值： create index dept_index on tb(dept)唯一： create unique index name_index on tb(name)复合： create index dept1_dept2_index on tb(dept1,dept2) 方式二：alter table \u003c表名\u003e add \u003c索引类型\u003e \u003c索引名(字段)\u003e单值： alter table tb add index dept_index(dept)唯一： alter table tb add unique index name_index(name)复合： alter table tb add index dept1_dept2_index(dept1,dept2) 删除索引\ndrop index 索引名 on 表名 查询索引\nshow index from 表名 sql优化 sql优化主要通过优化索引完成。通过explain分析sql的执行计划，可以模拟sql优化器执行sql语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析查询语句或是表结构的性能瓶颈。\nEXPLAIN 使用方式 EXPLAIN + SQL 语句 执行计划包含的信息\n表的读取顺序 ( id ) 数据读取操作的操作类型 ( select_type ) 每个子查询使用了哪种类型 ( type ) 哪些索引可以使用 ( possible_keys ) 哪些索引被实际使用 ( key ) 索引的长度 ( key_len ) 表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 ( ref ) 每张表有多少行被优化器查询 ( rows ) 执行计划各字段含义： id id 相同，执行顺序由上至下 id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行 id 同时存在相同的和不同的,还是按照上面两个规则执行 id 为 null 时表示一个结果集，不需要使用它查询，常出现在包含 union 等查询语句中 执行计划各字段含义： select_type 分别用来表示查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。\nSIMPLE 简单的 select 查询，查询中不包含子查询或者 union PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为 primary SUBQUERY 在 select 或 where 列表中包含了子查询 DERIVED 在 from 列表中包含的子查询被标记为 derived（衍生），MySQL 会递归执行这些子查询，把结果放在临时表中 UNION 若第二个 select 出现在 union 之后，则被标记为 union，若 union 包含在 from - 子句的子查询中，外层 select 将被标记为：derived UNION RESULT 从 union 表获取结果的 select 执行计划各字段含义： table 标识查询的数据表\n若查询时表使用了别名，则 table 显示别名； 当从衍生表（即临时表）中查数据时会显示 , x 表示对应的执行计划 id； 若显示 ，也表示一个临时表，表示这个结果来自于执行计划 id 为 x，y 的结果集； 执行计划各字段含义： type type 所显示的是查询使用了哪种类型，type 包含的类型包括如所示的几种：\nsystem \u003e const \u003e eq_ref \u003e ref \u003e range \u003e index \u003e all 一般来说，得保证查询至少达到 range 级别，最好能达到 ref\nNULL MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引 system 表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也可以忽略不计 const 表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量 eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描 ref 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体 range 只检索给定范围的行，使用一个索引来选择行，key 列显示使用了哪个索引，一般就是在你的 where 语句中出现 between、\u003c 、\u003e、in 等的查询，这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引 index Full Index Scan，Index 与 All 区别为 index 类型只遍历索引树。这通常比 All 快，因为索引文件通常比数据文件小。（也就是说虽然 All 和Index都是读全表，但 Index 是从索引中读取的，而 All 是从硬盘读取的） all Full Table Scan 将遍历全表以找到匹配的行 执行计划各字段含义： possible_keys 和 key possible_keys\n显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。\nkey\n实际使用的索引，如果为NULL，则没有使用索引。（可能原因包括没有建立索引或索引失效） 查询中若使用了覆盖索引（select 后要查询的字段刚好和创建的索引字段完全相同），则该索引仅出现在 key 列表中 执行计划各字段含义： key_len 查询中若使用了覆盖索引（select 后要查询的字段刚好和创建的索引字段完全相同），则该索引仅出现在 key 列表中\n执行计划各字段含义：ref 显示索引的那一列被使用了，如果可能的话，最好是一个常数。哪些列或常量被用于查找索引列上的值\n执行计划各字段含义： rows 根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数，也就是说，用的越少越好\n执行计划各字段含义： Extra Using filesort：说明 MySQL 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”。 Using temporary：表示 MySQL 需要使用临时表来存储结果集，常见于 order by 和 group by。 Using index：表示相应的 select 操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表明索引用来读取数据而非执行查找动作。 Using where：表明使用了where过滤 Using join buffer：表明使用了连接缓存，比如说在查询的时候，多表 join 的次数非常多，那么将配置文件中的缓冲区的 join buffer 调大一些。 impossible where：where 子句的值总是 false，不能用来获取任何元组 select tables optimized away：在没有 group by 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 distinct：优化 distinct 操作，在找到第一匹配的元组后即停止找同样值的动作 firstmatch：5.6.x 开始引入的优化子查询的新特性之一，常见于 where 字句含有 in() 类型的子查询。如果内表的数据量比较大，就可能出现这个 loosescan：5.6.x 之后引入的优化子查询的新特性之一，在 in() 类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个 ","wordCount":"2960","inLanguage":"en","datePublished":"2024-02-21T11:30:51+08:00","dateModified":"2024-03-21T00:48:39+08:00","author":{"@type":"Person","name":"luolin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"},"publisher":{"@type":"Organization","name":"luolin1024","logo":{"@type":"ImageObject","url":"https://luolin1024.github.io/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luolin1024.github.io accesskey=h title="luolin的博客 (Alt + H)">luolin的博客</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://luolin1024.github.io/posts title=📚文章><span>📚文章</span></a></li><li><a href=https://luolin1024.github.io/archives/ title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luolin1024.github.io/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luolin1024.github.io/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luolin1024.github.io/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luolin1024.github.io/links title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://luolin1024.github.io>Home</a>&nbsp;»&nbsp;<a href=https://luolin1024.github.io/blog_prepublish/>Blog_prepublishes</a></div><h1 class="post-title entry-hint-parent">MySql性能优化基本知识</h1><div class=post-meta><span title='2024-02-21 11:30:51 +0800 +0800'>2024-02-21</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;2960 words&nbsp;·&nbsp;luolin
本文总阅读量 <span id=umami_value_page_pv></span> 次
本文总访客量 <span id=umami_value_page_uv></span> 人</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#mysql%e5%88%86%e5%b1%82%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e aria-label=Mysql分层、存储引擎>Mysql分层、存储引擎</a></li><li><a href=#sql%e8%a7%a3%e6%9e%90%e8%bf%87%e7%a8%8b%e7%b4%a2%e5%bc%95b%e6%a0%91 aria-label=sql解析过程、索引、B树>sql解析过程、索引、B树</a><ul><li><a href=#sql%e8%a7%a3%e6%9e%90%e8%bf%87%e7%a8%8b aria-label=sql解析过程>sql解析过程</a></li><li><a href=#%e7%b4%a2%e5%bc%95 aria-label=索引>索引</a></li></ul></li></ul><li><a href=#sql%e4%bc%98%e5%8c%96 aria-label=sql优化>sql优化</a><ul><li><a href=#explain-%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f aria-label="EXPLAIN 使用方式">EXPLAIN 使用方式</a><ul><li><a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%90%84%e5%ad%97%e6%ae%b5%e5%90%ab%e4%b9%89-id aria-label="执行计划各字段含义： id">执行计划各字段含义： id</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%90%84%e5%ad%97%e6%ae%b5%e5%90%ab%e4%b9%89-select_type aria-label="执行计划各字段含义： select_type">执行计划各字段含义： select_type</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%90%84%e5%ad%97%e6%ae%b5%e5%90%ab%e4%b9%89-table aria-label="执行计划各字段含义： table">执行计划各字段含义： table</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%90%84%e5%ad%97%e6%ae%b5%e5%90%ab%e4%b9%89-type aria-label="执行计划各字段含义： type">执行计划各字段含义： type</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%90%84%e5%ad%97%e6%ae%b5%e5%90%ab%e4%b9%89-possible_keys-%e5%92%8c-key aria-label="执行计划各字段含义： possible_keys 和 key">执行计划各字段含义： possible_keys 和 key</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%90%84%e5%ad%97%e6%ae%b5%e5%90%ab%e4%b9%89-key_len aria-label="执行计划各字段含义： key_len">执行计划各字段含义： key_len</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%90%84%e5%ad%97%e6%ae%b5%e5%90%ab%e4%b9%89ref aria-label=执行计划各字段含义：ref>执行计划各字段含义：ref</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%90%84%e5%ad%97%e6%ae%b5%e5%90%ab%e4%b9%89-rows aria-label="执行计划各字段含义： rows">执行计划各字段含义： rows</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%90%84%e5%ad%97%e6%ae%b5%e5%90%ab%e4%b9%89-extra aria-label="执行计划各字段含义： Extra">执行计划各字段含义： Extra</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=mysql分层存储引擎>Mysql分层、存储引擎<a hidden class=anchor aria-hidden=true href=#mysql分层存储引擎>#</a></h3><p>常用引擎对比：InnoDB:事务优先(适合高并发操作，使用行锁)
MyISAM:性能优先（使用表锁）</p><p>可以使用<code>show engines;</code>查看当前使用数据库支持哪些引擎；使用<code>show VARIABLES LIKE '%storage_engine%';</code>正在使用的引擎。</p><h3 id=sql解析过程索引b树>sql解析过程、索引、B树<a hidden class=anchor aria-hidden=true href=#sql解析过程索引b树>#</a></h3><h4 id=sql解析过程>sql解析过程<a hidden class=anchor aria-hidden=true href=#sql解析过程>#</a></h4><p>一条sql示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>DISTINCT</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&lt;</span><span class=w> </span><span class=n>select_list</span><span class=w> </span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&lt;</span><span class=w> </span><span class=n>left_table</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>join_type</span><span class=w> </span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>JOIN</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>right_table</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>join_condition</span><span class=w> </span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&lt;</span><span class=w> </span><span class=n>where_condition</span><span class=w> </span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&lt;</span><span class=w> </span><span class=n>group_by_list</span><span class=w> </span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>HAVING</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&lt;</span><span class=w> </span><span class=n>having_condition</span><span class=w> </span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&lt;</span><span class=w> </span><span class=n>order_by_condition</span><span class=w> </span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LIMIT</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>limit_number</span><span class=w> </span><span class=o>&gt;</span><span class=w>
</span></span></span></code></pre></div><p>然而它的执行过程却是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=o>&lt;</span><span class=n>left_table</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ON</span><span class=w> </span><span class=o>&lt;</span><span class=n>join_condition</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=n>join_type</span><span class=o>&gt;</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=o>&lt;</span><span class=n>right_table</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=o>&lt;</span><span class=n>where_condition</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=o>&lt;</span><span class=n>group_by_list</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>HAVING</span><span class=w> </span><span class=o>&lt;</span><span class=n>having_condition</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>DISTINCT</span><span class=w> </span><span class=o>&lt;</span><span class=n>select_list</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=o>&lt;</span><span class=n>order_by_condition</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LIMIT</span><span class=w> </span><span class=o>&lt;</span><span class=n>limit_number</span><span class=o>&gt;</span><span class=w>
</span></span></span></code></pre></div><h4 id=索引>索引<a hidden class=anchor aria-hidden=true href=#索引>#</a></h4><p>索引相当于书的目录，可以帮助Mysql高效获取数据的数据结构，一般使用树、B树、Hash树..完成</p><p>索引的弊端：</p><ol><li>索引本身很大，可以存放在内存/硬盘（通常为硬盘）</li><li>索引不是所有情况均适用：少量数据频繁更新的字段很少使用的字段</li><li>索引会降低增删改的效率</li></ol><p>索引的优势：</p><ol><li>提高查询效率（降低IO使用率）</li><li>降低CPU使用率(&mldr; order by age desc，因为B树索引本身就是一个排好序的结构，不再需要排序)</li></ol><p><strong>索引分类</strong></p><ul><li>主键索引：不能重复。id 不能是null</li><li>唯一索引：不能重复。id 可以是null</li><li>单值索引：单列，age；一个表可以有多个单值索引,name。</li><li>复合索引：多个列构成的索引（相当于二级目录：z:zhao）</li></ul><p><strong>创建索引</strong></p><ol><li>方式一：create &lt;索引类型> &lt;索引名> on &lt;表名(字段)>单值： <code>create index dept_index on tb(dept)</code>唯一： <code>create unique index name_index on tb(name)</code>复合： <code>create index dept1_dept2_index on tb(dept1,dept2)</code></li><li>方式二：alter table &lt;表名> add &lt;索引类型> &lt;索引名(字段)>单值： <code>alter table tb add index dept_index(dept)</code>唯一： <code>alter table tb add unique index name_index(name)</code>复合： <code>alter table tb add index dept1_dept2_index(dept1,dept2)</code></li></ol><p><strong>删除索引</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>drop</span><span class=w> </span><span class=k>index</span><span class=w> </span><span class=err>索引名</span><span class=w> </span><span class=k>on</span><span class=w> </span><span class=err>表名</span><span class=w>
</span></span></span></code></pre></div><p><strong>查询索引</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>show</span><span class=w> </span><span class=k>index</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=err>表名</span><span class=w>
</span></span></span></code></pre></div><h2 id=sql优化>sql优化<a hidden class=anchor aria-hidden=true href=#sql优化>#</a></h2><p>sql优化主要通过优化索引完成。通过<code>explain</code>分析sql的执行计划，可以模拟sql优化器执行sql语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析查询语句或是表结构的性能瓶颈。</p><h3 id=explain-使用方式>EXPLAIN 使用方式<a hidden class=anchor aria-hidden=true href=#explain-使用方式>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>EXPLAIN</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=k>SQL</span><span class=w> </span><span class=err>语句</span><span class=w>
</span></span></span></code></pre></div><p>执行计划包含的信息</p><ul><li>表的读取顺序 ( id )</li><li>数据读取操作的操作类型 ( select_type )</li><li>每个子查询使用了哪种类型 ( type )</li><li>哪些索引可以使用 ( possible_keys )</li><li>哪些索引被实际使用 ( key )</li><li>索引的长度 ( key_len )</li><li>表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 ( ref )</li><li>每张表有多少行被优化器查询 ( rows )</li></ul><h4 id=执行计划各字段含义-id>执行计划各字段含义： id<a hidden class=anchor aria-hidden=true href=#执行计划各字段含义-id>#</a></h4><ul><li>id 相同，执行顺序由上至下</li><li>id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行</li><li>id 同时存在相同的和不同的,还是按照上面两个规则执行</li><li>id 为 null 时表示一个结果集，不需要使用它查询，常出现在包含 union 等查询语句中</li></ul><h4 id=执行计划各字段含义-select_type>执行计划各字段含义： select_type<a hidden class=anchor aria-hidden=true href=#执行计划各字段含义-select_type>#</a></h4><p>分别用来表示查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</p><ul><li>SIMPLE 简单的 select 查询，查询中不包含子查询或者 union</li><li>PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为 primary</li><li>SUBQUERY 在 select 或 where 列表中包含了子查询</li><li>DERIVED 在 from 列表中包含的子查询被标记为 derived（衍生），MySQL 会递归执行这些子查询，把结果放在临时表中</li><li>UNION 若第二个 select 出现在 union 之后，则被标记为 union，若 union 包含在 from - 子句的子查询中，外层 select 将被标记为：derived</li><li>UNION RESULT 从 union 表获取结果的 select</li></ul><h4 id=执行计划各字段含义-table>执行计划各字段含义： table<a hidden class=anchor aria-hidden=true href=#执行计划各字段含义-table>#</a></h4><p>标识查询的数据表</p><ol><li>若查询时表使用了别名，则 table 显示别名；</li><li>当从衍生表（即临时表）中查数据时会显示 , x 表示对应的执行计划 id；</li><li>若显示 &lt;union x,y>，也表示一个临时表，表示这个结果来自于执行计划 id 为 x，y 的结果集；</li></ol><h4 id=执行计划各字段含义-type>执行计划各字段含义： type<a hidden class=anchor aria-hidden=true href=#执行计划各字段含义-type>#</a></h4><p>type 所显示的是查询使用了哪种类型，type 包含的类型包括如所示的几种：</p><pre tabindex=0><code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all
</code></pre><blockquote><p>一般来说，得保证查询至少达到 range 级别，最好能达到 ref</p></blockquote><ul><li>NULL MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引</li><li>system 表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也可以忽略不计</li><li>const 表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量</li><li>eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li><li>ref 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体</li><li>range 只检索给定范围的行，使用一个索引来选择行，key 列显示使用了哪个索引，一般就是在你的 where 语句中出现 between、&lt; 、>、in 等的查询，这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引</li><li>index Full Index Scan，Index 与 All 区别为 index 类型只遍历索引树。这通常比 All 快，因为索引文件通常比数据文件小。（也就是说虽然 All 和Index都是读全表，但 Index 是从索引中读取的，而 All 是从硬盘读取的）</li><li>all Full Table Scan 将遍历全表以找到匹配的行</li></ul><h4 id=执行计划各字段含义-possible_keys-和-key>执行计划各字段含义： possible_keys 和 key<a hidden class=anchor aria-hidden=true href=#执行计划各字段含义-possible_keys-和-key>#</a></h4><p><strong>possible_keys</strong></p><p>显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</p><p><strong>key</strong></p><ul><li>实际使用的索引，如果为NULL，则没有使用索引。（可能原因包括没有建立索引或索引失效）</li><li>查询中若使用了覆盖索引（select 后要查询的字段刚好和创建的索引字段完全相同），则该索引仅出现在 key 列表中</li></ul><h4 id=执行计划各字段含义-key_len>执行计划各字段含义： key_len<a hidden class=anchor aria-hidden=true href=#执行计划各字段含义-key_len>#</a></h4><p>查询中若使用了覆盖索引（select 后要查询的字段刚好和创建的索引字段完全相同），则该索引仅出现在 key 列表中</p><h4 id=执行计划各字段含义ref>执行计划各字段含义：ref<a hidden class=anchor aria-hidden=true href=#执行计划各字段含义ref>#</a></h4><p>显示索引的那一列被使用了，如果可能的话，最好是一个常数。哪些列或常量被用于查找索引列上的值</p><h4 id=执行计划各字段含义-rows>执行计划各字段含义： rows<a hidden class=anchor aria-hidden=true href=#执行计划各字段含义-rows>#</a></h4><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数，也就是说，用的越少越好</p><h4 id=执行计划各字段含义-extra>执行计划各字段含义： Extra<a hidden class=anchor aria-hidden=true href=#执行计划各字段含义-extra>#</a></h4><ul><li>Using filesort：说明 MySQL 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”。</li><li>Using temporary：表示 MySQL 需要使用临时表来存储结果集，常见于 order by 和 group by。</li><li>Using index：表示相应的 select 操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表明索引用来读取数据而非执行查找动作。</li><li>Using where：表明使用了where过滤</li><li>Using join buffer：表明使用了连接缓存，比如说在查询的时候，多表 join 的次数非常多，那么将配置文件中的缓冲区的 join buffer 调大一些。</li><li>impossible where：where 子句的值总是 false，不能用来获取任何元组</li><li>select tables optimized away：在没有 group by 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li><li>distinct：优化 distinct 操作，在找到第一匹配的元组后即停止找同样值的动作</li><li>firstmatch：5.6.x 开始引入的优化子查询的新特性之一，常见于 where 字句含有 in() 类型的子查询。如果内表的数据量比较大，就可能出现这个</li><li>loosescan：5.6.x 之后引入的优化子查询的新特性之一，在 in() 类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://luolin1024.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/>数据库/Mysql</a></li><li><a href=https://luolin1024.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>性能优化</a></li></ul><nav class=paginav><a class=prev href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%A4%A7%E8%A1%A8%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/><span class=title>« Prev</span><br><span>MySql大表更新方案</span></a>
<a class=next href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%AD%BB%E9%94%81%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B%E4%B8%8E%E5%88%86%E6%9E%90/><span class=title>Next »</span><br><span>MySQL死锁日志查看与分析</span></a></nav><div class=related-posts><h2>相关文章</h2><ul><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-rc%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90/>Mysql rc隔离级别下的死锁分析</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-b+-%E6%A0%91%E6%9D%A5%E4%BD%9C%E7%B4%A2%E5%BC%95%E5%AF%B9%E6%AF%94-b-%E6%A0%91%E5%AE%83%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88/>MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%A4%A7%E8%A1%A8%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/>MySql大表更新方案</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%AD%BB%E9%94%81%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B%E4%B8%8E%E5%88%86%E6%9E%90/>MySQL死锁日志查看与分析</a></li><li>· <a href=/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/>MySQL索引数据结构分析</a></li></ul></div></footer><link rel=stylesheet href=https://unpkg.com/@waline/client@v2/dist/waline.css><div id=waline></div><script type=module>
    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
    const locale = {
        nick: '昵称',
        nickError: '请填写昵称',
        mail: '邮箱',
        mailError: '请填写正确的邮件地址',
        link: '网址',
        optional: '可选',
        placeholder: '仅填写昵称即可发表回复。\n填写邮箱可收到回复提醒。\n评论区支持 Markdown 语法及预览。\n',
        sofa: '来发评论吧~',
        submit: '提交',
        like: '喜欢',
        cancelLike: '取消喜欢',
        reply: '回复',
        cancelReply: '取消回复',
        comment: '评论',
        refresh: '刷新',
        more: '加载更多...',
        preview: '预览',
        emoji: '表情',
        uploadImage: '上传图片',
        seconds: '秒前',
        minutes: '分钟前',
        hours: '小时前',
        days: '天前',
        now: '刚刚',
        uploading: '正在上传',
        login: '管理',
        logout: '退出',
        admin: '博主',
        sticky: '置顶',
        word: '字',
        wordHint: '评论字数应在 $0 到 $1 字之间！\n当前字数：$2',
        anonymous: '匿名',
        level0: '潜水',
        level1: '冒泡',
        level2: '吐槽',
        level3: '活跃',
        level4: '话痨',
        level5: '传说',
        gif: '表情包',
        gifSearchPlaceholder: '搜索表情包',
        profile: '个人资料',
        approved: '通过',
        waiting: '待审核',
        spam: '垃圾',
        unsticky: '取消置顶',
        oldest: '按倒序',
        latest: '按正序',
        hottest: '按热度',
        reactionTitle: '你认为这篇文章怎么样？',
    };
    init({
        
        el: '#waline',
        serverURL: 'https://blogcomments.luolin.online',
        locale,
        emoji: false,     
        search: false,    
        reaction: false,  
        requiredMeta: ['nick'],
        pageSize: 10,
        imageUploader: false,
        copyright: true,
        pageview: true,
        like: false,
    });
</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://luolin1024.github.io>luolin1024</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div>本站总访问量 <span id=umami_value_site_pv></span> 次
本站总访客数 <span id=umami_value_site_uv></span> 人
当前在线访客 <span id=umami_value_active_uv></span> 人</div><a href="https://icp.gov.moe/?keyword=20248618" target=_blank>萌ICP备20248618号</a></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>