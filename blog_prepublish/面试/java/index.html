<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java知识 | luolin1024</title><meta name=keywords content="面试"><meta name=description content="Java基础 Java中的基本类型都有哪些 数字类型 4 种整数型：byte、short、int、long，int:4个字节 2 种浮点型：float、"><meta name=author content="luolin"><link rel=canonical href=https://luolin1024.github.io/blog_prepublish/%E9%9D%A2%E8%AF%95/java/><script defer src=https://blogcounter.luolin.us.kg/script.js data-website-id=c8850e2c-16aa-465e-aa6f-5392c9397317></script>
<script src=/js/umami-stats.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luolin1024.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://luolin1024.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://luolin1024.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://luolin1024.github.io/apple-touch-icon.png><link rel=mask-icon href=https://luolin1024.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><html><head><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css><style>body{font-family:lxgw wenkai lite,sans-serif;font-family:lxgw wenkai screen,sans-serif}</style></head></html><meta property="og:title" content="Java知识"><meta property="og:description" content="Java基础 Java中的基本类型都有哪些 数字类型 4 种整数型：byte、short、int、long，int:4个字节 2 种浮点型：float、"><meta property="og:type" content="article"><meta property="og:url" content="https://luolin1024.github.io/blog_prepublish/%E9%9D%A2%E8%AF%95/java/"><meta property="article:section" content="blog_prepublish"><meta property="article:published_time" content="2023-12-06T15:24:18+08:00"><meta property="article:modified_time" content="2024-03-21T00:55:47+08:00"><meta property="og:site_name" content="luolin的博客"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java知识"><meta name=twitter:description content="Java基础 Java中的基本类型都有哪些 数字类型 4 种整数型：byte、short、int、long，int:4个字节 2 种浮点型：float、"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog_prepublishes","item":"https://luolin1024.github.io/blog_prepublish/"},{"@type":"ListItem","position":2,"name":"Java知识","item":"https://luolin1024.github.io/blog_prepublish/%E9%9D%A2%E8%AF%95/java/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java知识","name":"Java知识","description":"Java基础 Java中的基本类型都有哪些 数字类型 4 种整数型：byte、short、int、long，int:4个字节 2 种浮点型：float、","keywords":["面试"],"articleBody":"Java基础 Java中的基本类型都有哪些 数字类型 4 种整数型：byte、short、int、long，int:4个字节 2 种浮点型：float、double 字符类型 char：2个字节 布尔型 boolean 包装类型 常量池技术 自动装箱与拆箱 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； \u0026 和\u0026\u0026 的区别 \u0026：按位与 \u0026\u0026：与\n面向对象三大特征 封装 继承 多态 值传递\u0026引用传递 [[Java传参机制]] [[Java浅拷贝和深拷贝]] Object hashCode() 与 equals()与== 这三者的区别 == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。 equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“ == ”比较这两个对象。 情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。 hashCode() 的作用是获取哈希码，hashCode() 在散列表中才有用，在其它情况下没用。 为什么重写 equals() 时必须重写 hashCode() 方法？ 因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。 如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。 重写 equals() 时没有重写 hashCode() 方法的话，使用 HashMap 可能会出现什么问题? hashCode() 在散列表中才有用，在其它情况下没用。 散列表，指的是：Java集合中本质是散列表的类，如HashMap，Hashtable，HashSet。 重载和重写 重载：同名方法不同参数数量 重写：子类重写父类的同名方法，目的：提高扩展性 泛型 泛型中extends和super的区别 String、StringBuffer、StringBuilder String 为什么是不可变的? 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。 String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。 线程安全性 String 线程安全 StringBufffer线程安全 StringBuilder非线程安全 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer 参数 可变长参数 泛型 泛型类、泛型接口、泛型方法。 反射 优点 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利 缺点 让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。 代码可读性 应用场景 框架中以及动态代理 注解 编译期直接扫描 运行期通过反射处理 自定义注解 异常 Throwable\nError Exception try-catch-finally\nfinally 中的代码一定会执行吗 不一定的！在某些情况下，finally 中的代码不会被执行。 就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。 OOM jstack heap dump I/O 序列化\n将数据结构或对象转换成二进制字节流的过程 反序列化\n将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程 Java 序列化中如果有些字段不想进行序列化，怎么办？\n对于不想进行序列化的变量，使用 transient 关键字修饰。 字节流,为什么还要有字符流?\n不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？ 字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。 Stream 函数式接口 集合类 List ArrayList LinkedLst HashTable hashmap和hashtable的区别 哈希计算方法不同 HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模。 Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模。 负载因子：0.75 尽量不使用，推荐使用ConcurrentHashMap Map HashMap 重写equals不重写hashCode会怎样？ HashMap如何实现线程安全？ HashMap本身底层是非线程安全的，在多线程条件下，容易导致死循环，具体表现为CPU使用率100%。实现线程安全方法 使用 java.util.Hashtable 类，此类是线程安全的。【通过方法上添加synchronized实现线程安全，建议使用ConcurrentHashMap】 使用 java.util.concurrent.ConcurrentHashMap，此类是线程安全的。【put元素时使用synchronized关键字修饰】 使用 java.util.Collections.synchronizedMap() 方法包装 HashMap object，得到线程安全的Map，并在此Map上进行操作。【方法返回SynchronizedMap】 自己在程序的关键方法或者代码段加锁，保证安全性，当然这是严重的不推荐。 ConcurrentHashMap ConcurrentHashMap与HashMap的区别 基本概念不同；ConcurrentHashMap是一个支持高并发更新与查询的哈希表；而HashMap是基于哈希表的Map接口的实现。 底层数据结构不同；HashMap的底层数据结构主要是：数组+链表，确切的说是由链表为元素的数组。ConcurrentHashMap的底层数据结构是：Segments数组+HashEntry数组+链表。ConcurrentHashMap是线程安全的数组，它采用分段锁保证安全性。容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。而HashMap不是线程安全，没有锁机制，在多线程环境下会导致数据覆盖之类的问题，所以在多线程中使用HashMap是会抛出异常的。 线程安全属性不同； 对整个桶数组的处理方式不同。 谈谈ConcurrentHashMap的扩容机制 Java 并发 线程的生命周期？线程有几种状态 Java里面synchronized锁的底层实现原理？ 对象锁[[synchronized 实现原理]] 介绍一下悲观锁、乐观锁、自旋锁，适用场景？ 对于传统的重量级锁（synchronized）提供一系列优化操作——自旋与自适应自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）。 sleep()、 wait()、 join()、 yielo()红超间的的区别 对线程安全的理解 线程安全可以理解为内存安全，堆是内存共享，可以被所有的内存访问。 当多个线程访问同一个对象时，如果不进行额外的同步控制或者其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。 为什么出现现场不安全？ 其中一个线程修改了堆内存区域的对象属性，或者某个值，导致其他线程拿到错误的对象属性 Thread和Runable的区别 对守护线程的理解 ThreadLocal的底层原理 每个Thread都维护自己的一个ThreadLocalMap ，所以是线程隔离的。 并发、并行、串行之间的区别 Java死锁如何避免？ 死锁的四个必要不充分条件 禁止抢占 持有和等待 互斥 循环等待 如何理解volatile关键字 为什么用线程池？解释下线程池参数？（7个线程池参数） corePoolSize：核心线程数。 maximumPoolSize：最大线程数。 keepAliveTime：空闲线程存活时间。 TimeUnit：时间单位。 BlockingQueue：线程池任务队列。 ThreadFactory：创建线程的工厂。 RejectedExecutionHandler：拒绝策略。（4个拒绝策略） AbortPolicy：拒绝并抛出异常。 CallerRunsPolicy：使用当前调用的线程来执行此任务。 DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。 DiscardPolicy：忽略并抛弃当前任务。 最大任务数量=maximumPoolSize+BlockingQueue 线程池的底层工作原理 线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程? 线程池中线程复用原理 线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停的检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的 run 方法，将 run 方法当成一个普通的方法执行，通过这种方式将只使用固定的线程就将所有任务的 run 方法串联起来。 ReentrantLock中的公平锁和非公平锁的底层实现 ReentrantLock中tryLocko和lock0方法的区别 CountDownLatch和Semaphore的区别和底层原理 Sychronized的偏向锁、轻量级锁、重量级锁 Sychronized和ReentrantLock的区别 谈谈你对AQS的理解，AQS如何实现可重入锁？ JVM 一个JVM进程的内存布局空间？ 线程共享内存区 Java堆： 虚拟机启动时创建，用来存放对象实例 新生代 1. 老年代 方法区 永久代（元空间），大多是静态方法 线程私有内存区 Java虚拟机栈 Java虚拟机栈也是线程私有的，虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的时候都会创建一个栈帧，用于存放局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直到执行完成的过程都对应着一个栈帧在虚拟机中的入栈到出栈的过程。我们平时把内存分为堆内存和栈内存，其中的栈内存就指的是虚拟机栈的局部变量表部分。局部变量表存放了编译期可以知道的基本数据类型(boolean、byte、char、short、int、float、long、double)，对象引用(可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置)，和返回后所指向的字节码的地址。其中64 位长度的long 和double 类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。当递归层次太深时，会引发java.lang.StackOverflowError，这是虚拟机栈抛出的异常。 本地方法栈 native方法栈 程序计数器 函数返回的时候，return语句的执行过程？ Java中有哪些类加载器 引导（Bootstrap）类加载器 扩展（Extensions）类加载器 Apps类加载器（也称系统类加载器） 自定义类加载器 类加载器之间的关系 启动类加载器，由C++实现，没有父类。 拓展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null 系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader 自定义类加载器，父类加载器肯定为AppClassLoader。 说说类加载器双亲委派模型 其工作原理的是：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成。 作用： 避免类的重复加载； 防止核心API库被随意篡改 GC如何判断对象可以被回收 引用计数法 优点：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。 缺点：难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。 可达性分析法 可达性分析是用来判断对象是否存活，通过\"GC Roots\"作为起点，从这个节点往下搜索，如果有有引用，则这个对象是存活的，如果没有则判定可回收的对象。 垃圾回收算法 标记-清除算法 标记-清除算法对根集合进行扫描，对存活的对象进行标记。标记完成后，再对整个空间内未被标记的对象扫描，进行回收。 优点：实现简单，不需要进行对象进行移动。 缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。 复制算法 它将内存区域划分成相同的两个内存块。每次仅使用一半的空间，JVM生成的新对象放在一半空间中。当一半空间用完时进行GC，把可到达对象复制到另一半空间，然后把使用过的内存空间一次清理掉。 优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。 缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。 标记-整理算法 标记-整理算法 采用和 标记-清除算法 一样的方式进行对象的标记，但后续不直接对可回收对象进行清理，而是将所有的存活对象往一端空闲空间移动，然后清理掉端边界以外的内存空间。 优点：解决了标记-清理算法存在的内存碎片问题。 缺点：仍需要进行局部对象移动，一定程度上降低了效率。 分代收集算法 总结 JDK8堆内存一般是划分为年轻代和老年代，不同年代 根据自身特性采用不同的垃圾收集算法。 对于新生代，每次GC时都有大量的对象死亡，只有少量对象存活。考虑到复制成本低，适合采用复制算法。因此有了From Survivor和To Survivor区域。 对于老年代，因为对象存活率高，没有额外的内存空间对它进行担保。因而适合采用标记-清理算法和标记-整理算法进行回收。 JVM中哪些是线程共享区 堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的 堆: 不用多说了,放对象的地方 方法区: 类定义的成员变量丶常量丶静态变量丶方法都在这里 栈: 程序运行才有的,会把运行时的方法压入栈,里面有局部变量等东西 本地方法栈: 操作系统方法 程序计数器: 标记代码走到哪里了 你们项目如何排查JVM问题 一个对象从加载到JVM，再到被GC清除，都经历了什么过程？ 什么是三色标记？ CMS怎么进行垃圾回收的？ 官方名称：最大-并发-标记-清除-垃圾收集器 作用范围：老年代 算法：并发标记清除算法。 阶段 初始标记（CMS initial mark） STW 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） JVM参数有哪些？ 1. -Xms：设置初始分配大小，默认为物理内存的1/64 2. -Xmx：最大分配内存，默认为物理内存的1/4 3. -XX:+PrintGCDetails：输出详细的GC处理日志 4. -XX:+PrintGCTimeStamps：输出GC的时间戳信息 5. -XX:+PrintGCDateStamps：输出GC的时间戳信息（以日期的形式） 6. -XX:+PrintHeapAtGC：在GC进行处理的前后打印堆内存信息 7. -Xloggc:(SavePath)：设置日志信息保存文件 8. 在堆内存的调整策略中，基本上只要调整两个参数：-Xms和-Xmx GC具体过程 当现在有一个新的对象产生，JvM需要为该对象进行内存空间的申请 先判断Eden区是否有内存空间，如果有，直接将新对象保存在Eden区 如果Eden区的内存空间不足，会自动执行一个MinorGC操作，将Eden区的无用内存空间进行清理 清理Eden区之后继续判断Eden区内存空间情况，如果充足，则将新对象直接保存在Eden区 如果执行了Minor GC之后发现Eden区的内存依然不足，那就判断存活区的内存空间，并将Eden区的部 分活跃对象保存在存活区 活跃对象迁移到存活区后，继续判断Eden区内存空间情况，如果充足，则将新对象直接保存在Eden区 如果存活区也没有空间了，则继续判断老年区，如果老年区充足，则将存活区的部分活跃对象保存在老 年区 存活区的活跃对象迁移到老年区后，则将Eden区的部分活跃对象保存在存活区 活跃对象迁移到存活区后，继续判断Eden区内存空间情况，如果充足，则将新对象直接保存在Eden区 如果老年区也满了，这时候产生Major GC (Ful GC)进行老年区的内存清理 如果老年区执行了 Major GC之后发现无法进行对象保存，会产生OutofMemoryError异常 GC的区别 1、部分收集（Partial GC）：只针对部分区域进行垃圾收集。其中又分为： 1.1、新生代收集（Minor GC/Young GC）：只针对新生代的垃圾收集。具体点的是Eden区满时触发GC。 Survivor满不会触发Minor GC 。 1.2、老年代收集（Major GC/Old GC）：只针对 老年代的垃圾收集。 目前，只有CMS收集器会有单独收集老年代的行为。 注意，很多时候，Major GC 会和Full GC混淆使用，需要具体分辨是老年代的回收还是整堆回收。 1.3、混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有G1收集器会有这种行为。 2、整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。\t","wordCount":"7325","inLanguage":"en","datePublished":"2023-12-06T15:24:18+08:00","dateModified":"2024-03-21T00:55:47+08:00","author":{"@type":"Person","name":"luolin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://luolin1024.github.io/blog_prepublish/%E9%9D%A2%E8%AF%95/java/"},"publisher":{"@type":"Organization","name":"luolin1024","logo":{"@type":"ImageObject","url":"https://luolin1024.github.io/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luolin1024.github.io accesskey=h title="luolin的博客 (Alt + H)">luolin的博客</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://luolin1024.github.io/posts title=📚文章><span>📚文章</span></a></li><li><a href=https://luolin1024.github.io/archives/ title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luolin1024.github.io/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luolin1024.github.io/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luolin1024.github.io/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luolin1024.github.io/links title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://luolin1024.github.io>Home</a>&nbsp;»&nbsp;<a href=https://luolin1024.github.io/blog_prepublish/>Blog_prepublishes</a></div><h1 class="post-title entry-hint-parent">Java知识</h1><div class=post-meta><span title='2023-12-06 15:24:18 +0800 +0800'>2023-12-06</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;7325 words&nbsp;·&nbsp;luolin
本文总阅读量 <span id=umami_value_page_pv></span> 次
本文总访客量 <span id=umami_value_page_uv></span> 人</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#java%e5%9f%ba%e7%a1%80 aria-label=Java基础>Java基础</a><ul><li><a href=#java%e4%b8%ad%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e9%83%bd%e6%9c%89%e5%93%aa%e4%ba%9b aria-label=Java中的基本类型都有哪些>Java中的基本类型都有哪些</a></li><li><a href=#-%e5%92%8c-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="&amp;amp; 和&amp;amp;&amp;amp; 的区别">& 和&& 的区别</a></li><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e4%b8%89%e5%a4%a7%e7%89%b9%e5%be%81 aria-label=面向对象三大特征>面向对象三大特征</a></li><li><a href=#%e5%80%bc%e4%bc%a0%e9%80%92%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92 aria-label=值传递&amp;amp;引用传递>值传递&引用传递</a></li><li><a href=#object aria-label=Object>Object</a></li><li><a href=#hashcode-%e4%b8%8e--equals%e4%b8%8e-%e8%bf%99%e4%b8%89%e8%80%85%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="hashCode() 与  equals()与== 这三者的区别">hashCode() 与 equals()与== 这三者的区别</a></li><li><a href=#%e9%87%8d%e8%bd%bd%e5%92%8c%e9%87%8d%e5%86%99 aria-label=重载和重写>重载和重写</a></li><li><a href=#%e6%b3%9b%e5%9e%8b aria-label=泛型>泛型</a></li><li><a href=#stringstringbufferstringbuilder aria-label=String、StringBuffer、StringBuilder>String、StringBuffer、StringBuilder</a></li><li><a href=#%e5%8f%82%e6%95%b0 aria-label=参数>参数</a></li><li><a href=#%e6%b3%9b%e5%9e%8b-1 aria-label=泛型>泛型</a></li><li><a href=#%e5%8f%8d%e5%b0%84 aria-label=反射>反射</a></li><li><a href=#%e6%b3%a8%e8%a7%a3 aria-label=注解>注解</a></li><li><a href=#%e5%bc%82%e5%b8%b8 aria-label=异常>异常</a><ul><li><a href=#oom aria-label=OOM>OOM</a></li></ul></li><li><a href=#io aria-label=I/O>I/O</a></li><li><a href=#stream aria-label=Stream>Stream</a></li></ul></li><li><a href=#%e9%9b%86%e5%90%88%e7%b1%bb aria-label=集合类>集合类</a><ul><li><a href=#list aria-label=List>List</a></li><li><a href=#hashtable aria-label=HashTable>HashTable</a></li></ul></li><li><a href=#%e5%93%88%e5%b8%8c%e8%ae%a1%e7%ae%97%e6%96%b9%e6%b3%95%e4%b8%8d%e5%90%8c aria-label=哈希计算方法不同>哈希计算方法不同</a><ul><li><a href=#map aria-label=Map>Map</a></li></ul></li><li><a href=#java-%e5%b9%b6%e5%8f%91 aria-label="Java 并发">Java 并发</a></li><li><a href=#jvm aria-label=JVM>JVM</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=java基础>Java基础<a hidden class=anchor aria-hidden=true href=#java基础>#</a></h2><h3 id=java中的基本类型都有哪些>Java中的基本类型都有哪些<a hidden class=anchor aria-hidden=true href=#java中的基本类型都有哪些>#</a></h3><ul><li>数字类型<ul><li>4 种整数型：byte、short、int、long，int:4个字节</li><li>2 种浮点型：float、double</li></ul></li><li>字符类型<ul><li>char：2个字节</li></ul></li><li>布尔型<ul><li>boolean</li></ul></li><li>包装类型<ul><li>常量池技术</li></ul></li><li>自动装箱与拆箱<ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；</li></ul></li></ul><h3 id=-和-的区别>& 和&& 的区别<a hidden class=anchor aria-hidden=true href=#-和-的区别>#</a></h3><p>&：按位与
&&：与</p><h3 id=面向对象三大特征>面向对象三大特征<a hidden class=anchor aria-hidden=true href=#面向对象三大特征>#</a></h3><ul><li>封装</li><li>继承</li><li>多态</li></ul><h3 id=值传递引用传递>值传递&引用传递<a hidden class=anchor aria-hidden=true href=#值传递引用传递>#</a></h3><ul><li>[[Java传参机制]]</li><li>[[Java浅拷贝和深拷贝]]</li></ul><h3 id=object>Object<a hidden class=anchor aria-hidden=true href=#object>#</a></h3><h3 id=hashcode-与--equals与-这三者的区别>hashCode() 与 equals()与== 这三者的区别<a hidden class=anchor aria-hidden=true href=#hashcode-与--equals与-这三者的区别>#</a></h3><ul><li>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。</li><li>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：<ul><li>情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“ == ”比较这两个对象。</li><li>情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li></ul></li><li>hashCode() 的作用是获取哈希码，hashCode() 在散列表中才有用，在其它情况下没用。</li><li>为什么重写 equals() 时必须重写 hashCode() 方法？<ul><li>因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。</li></ul></li><li>如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。</li><li>重写 equals() 时没有重写 hashCode() 方法的话，使用 HashMap 可能会出现什么问题?<ul><li>hashCode() 在散列表中才有用，在其它情况下没用。</li><li>散列表，指的是：Java集合中本质是散列表的类，如HashMap，Hashtable，HashSet。</li></ul></li></ul><h3 id=重载和重写>重载和重写<a hidden class=anchor aria-hidden=true href=#重载和重写>#</a></h3><ul><li>重载：同名方法不同参数数量</li><li>重写：子类重写父类的同名方法，目的：提高扩展性</li></ul><h3 id=泛型>泛型<a hidden class=anchor aria-hidden=true href=#泛型>#</a></h3><ol><li>泛型中extends和super的区别</li></ol><h3 id=stringstringbufferstringbuilder>String、StringBuffer、StringBuilder<a hidden class=anchor aria-hidden=true href=#stringstringbufferstringbuilder>#</a></h3><ul><li>String 为什么是不可变的?<ul><li>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。</li><li>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</li></ul></li><li>线程安全性<ul><li>String 线程安全</li><li>StringBufffer线程安全</li><li>StringBuilder非线程安全</li></ul></li><li>性能<ul><li>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li><li>操作少量的数据: 适用 String
单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li></ul></li></ul><h3 id=参数>参数<a hidden class=anchor aria-hidden=true href=#参数>#</a></h3><ul><li>可变长参数</li></ul><h3 id=泛型-1>泛型<a hidden class=anchor aria-hidden=true href=#泛型-1>#</a></h3><ul><li>泛型类、泛型接口、泛型方法。</li></ul><h3 id=反射>反射<a hidden class=anchor aria-hidden=true href=#反射>#</a></h3><ul><li>优点<ul><li>可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li></ul></li><li>缺点<ul><li>让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li><li>代码可读性</li></ul></li><li>应用场景<ul><li>框架中以及动态代理</li></ul></li></ul><h3 id=注解>注解<a hidden class=anchor aria-hidden=true href=#注解>#</a></h3><ul><li>编译期直接扫描</li><li>运行期通过反射处理</li><li>自定义注解</li></ul><h3 id=异常>异常<a hidden class=anchor aria-hidden=true href=#异常>#</a></h3><ul><li><p>Throwable</p><ul><li>Error</li><li>Exception</li></ul></li><li><p>try-catch-finally</p><ul><li>finally 中的代码一定会执行吗<ul><li>不一定的！在某些情况下，finally 中的代码不会被执行。
就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</li></ul></li></ul></li></ul><h4 id=oom>OOM<a hidden class=anchor aria-hidden=true href=#oom>#</a></h4><ol><li>jstack</li><li>heap</li><li>dump</li></ol><h3 id=io>I/O<a hidden class=anchor aria-hidden=true href=#io>#</a></h3><ul><li><p>序列化</p><ul><li>将数据结构或对象转换成二进制字节流的过程</li></ul></li><li><p>反序列化</p><ul><li>将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul></li><li><p>Java 序列化中如果有些字段不想进行序列化，怎么办？</p><ul><li>对于不想进行序列化的变量，使用 transient 关键字修饰。</li></ul></li><li><p>字节流,为什么还要有字符流?</p><ul><li>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？<ul><li>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</li></ul></li></ul></li></ul><h3 id=stream>Stream<a hidden class=anchor aria-hidden=true href=#stream>#</a></h3><ul><li>函数式接口</li></ul><h2 id=集合类>集合类<a hidden class=anchor aria-hidden=true href=#集合类>#</a></h2><h3 id=list>List<a hidden class=anchor aria-hidden=true href=#list>#</a></h3><ul><li>ArrayList</li><li>LinkedLst</li></ul><h3 id=hashtable>HashTable<a hidden class=anchor aria-hidden=true href=#hashtable>#</a></h3><ol><li>hashmap和hashtable的区别<ol><li><h2 id=哈希计算方法不同>哈希计算方法不同<a hidden class=anchor aria-hidden=true href=#哈希计算方法不同>#</a></h2><ol><li>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模。</li><li>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模。</li></ol></li></ol></li><li>负载因子：0.75</li><li>尽量不使用，推荐使用ConcurrentHashMap</li></ol><h3 id=map>Map<a hidden class=anchor aria-hidden=true href=#map>#</a></h3><ul><li>HashMap<ul><li>重写equals不重写hashCode会怎样？</li><li>HashMap如何实现线程安全？<ul><li>HashMap本身底层是非线程安全的，在多线程条件下，容易导致死循环，具体表现为CPU使用率100%。实现线程安全方法<ol><li>使用 java.util.Hashtable 类，此类是线程安全的。【通过方法上添加synchronized实现线程安全，建议使用ConcurrentHashMap】</li><li>使用 java.util.concurrent.ConcurrentHashMap，此类是线程安全的。【put元素时使用synchronized关键字修饰】</li><li>使用 java.util.Collections.synchronizedMap() 方法包装 HashMap object，得到线程安全的Map，并在此Map上进行操作。【方法返回SynchronizedMap】</li><li>自己在程序的关键方法或者代码段加锁，保证安全性，当然这是严重的不推荐。</li></ol></li></ul></li></ul></li><li>ConcurrentHashMap<ol><li>ConcurrentHashMap与HashMap的区别<ol><li>基本概念不同；ConcurrentHashMap是一个支持高并发更新与查询的哈希表；而HashMap是基于哈希表的Map接口的实现。</li><li>底层数据结构不同；HashMap的底层数据结构主要是：数组+链表，确切的说是由链表为元素的数组。ConcurrentHashMap的底层数据结构是：Segments数组+HashEntry数组+链表。ConcurrentHashMap是线程安全的数组，它采用分段锁保证安全性。容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。而HashMap不是线程安全，没有锁机制，在多线程环境下会导致数据覆盖之类的问题，所以在多线程中使用HashMap是会抛出异常的。</li><li>线程安全属性不同；</li><li>对整个桶数组的处理方式不同。</li></ol></li><li>谈谈ConcurrentHashMap的扩容机制</li></ol></li></ul><h2 id=java-并发>Java 并发<a hidden class=anchor aria-hidden=true href=#java-并发>#</a></h2><ol><li>线程的生命周期？线程有几种状态</li><li>Java里面synchronized锁的底层实现原理？<ol><li>对象锁[[synchronized 实现原理]]</li></ol></li><li>介绍一下悲观锁、乐观锁、自旋锁，适用场景？<ol><li>对于传统的重量级锁（synchronized）提供一系列优化操作——自旋与自适应自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）。</li></ol></li><li>sleep()、 wait()、 join()、 yielo()红超间的的区别</li><li>对线程安全的理解<ol><li>线程安全可以理解为内存安全，堆是内存共享，可以被所有的内存访问。 当多个线程访问同一个对象时，如果不进行额外的同步控制或者其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。</li><li>为什么出现现场不安全？<ol><li>其中一个线程修改了堆内存区域的对象属性，或者某个值，导致其他线程拿到错误的对象属性</li></ol></li></ol></li><li>Thread和Runable的区别</li><li>对守护线程的理解</li><li>ThreadLocal的底层原理<ol><li>每个<code>Thread</code>都维护自己的一个<code>ThreadLocalMap</code> ，所以是线程隔离的。</li></ol></li><li>并发、并行、串行之间的区别</li><li>Java死锁如何避免？<ol><li>死锁的四个必要不充分条件<ol><li>禁止抢占</li><li>持有和等待</li><li>互斥</li><li>循环等待</li></ol></li></ol></li><li>如何理解volatile关键字</li><li>为什么用线程池？解释下线程池参数？（7个线程池参数）<ol><li>corePoolSize：核心线程数。</li><li>maximumPoolSize：最大线程数。</li><li>keepAliveTime：空闲线程存活时间。</li><li>TimeUnit：时间单位。</li><li>BlockingQueue：线程池任务队列。</li><li>ThreadFactory：创建线程的工厂。</li><li>RejectedExecutionHandler：拒绝策略。（4个拒绝策略）<ul><li>AbortPolicy：拒绝并抛出异常。</li><li>CallerRunsPolicy：使用当前调用的线程来执行此任务。</li><li>DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。</li><li>DiscardPolicy：忽略并抛弃当前任务。</li></ul></li><li>最大任务数量=maximumPoolSize+BlockingQueue</li></ol></li><li>线程池的底层工作原理</li><li>线程池中阻塞队列的作用？为什么是先添加列队而不是先创建最大线程?</li><li>线程池中线程复用原理<ol><li>线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”，在这个“循环任务”中不停的检查是否有任务需要被执行，如果有则直接执行，也就是调用任务中的 run 方法，将 run 方法当成一个普通的方法执行，通过这种方式将只使用固定的线程就将所有任务的 run 方法串联起来。</li></ol></li><li>ReentrantLock中的公平锁和非公平锁的底层实现</li><li>ReentrantLock中tryLocko和lock0方法的区别</li><li>CountDownLatch和Semaphore的区别和底层原理</li><li>Sychronized的偏向锁、轻量级锁、重量级锁</li><li>Sychronized和ReentrantLock的区别</li><li>谈谈你对AQS的理解，AQS如何实现可重入锁？</li></ol><h2 id=jvm>JVM<a hidden class=anchor aria-hidden=true href=#jvm>#</a></h2><ol><li>一个JVM进程的内存布局空间？<ol><li>线程共享内存区<ol><li>Java堆：<ol><li>虚拟机启动时创建，用来存放对象实例</li><li>新生代
1.</li><li>老年代</li></ol></li><li>方法区<ol><li>永久代（元空间），大多是静态方法</li></ol></li></ol></li><li>线程私有内存区<ol><li>Java虚拟机栈<ol><li>Java虚拟机栈也是线程私有的，虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的时候都会创建一个栈帧，用于存放局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直到执行完成的过程都对应着一个栈帧在虚拟机中的入栈到出栈的过程。我们平时把内存分为堆内存和栈内存，其中的栈内存就指的是虚拟机栈的局部变量表部分。局部变量表存放了编译期可以知道的基本数据类型(boolean、byte、char、short、int、float、long、double)，对象引用(可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置)，和返回后所指向的字节码的地址。其中64 位长度的long 和double 类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。当递归层次太深时，会引发java.lang.StackOverflowError，这是虚拟机栈抛出的异常。</li></ol></li><li>本地方法栈<ol><li>native方法栈</li></ol></li><li>程序计数器</li></ol></li></ol></li><li>函数返回的时候，return语句的执行过程？</li><li>Java中有哪些类加载器<ol><li>引导（Bootstrap）类加载器</li><li>扩展（Extensions）类加载器</li><li>Apps类加载器（也称系统类加载器）</li><li>自定义类加载器</li><li>类加载器之间的关系<ol><li>启动类加载器，由C++实现，没有父类。</li><li>拓展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null</li><li>系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader</li><li>自定义类加载器，父类加载器肯定为AppClassLoader。</li></ol></li></ol></li><li>说说类加载器双亲委派模型<ol><li>其工作原理的是：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成。</li><li>作用：<ol><li>避免类的重复加载；</li><li>防止核心API库被随意篡改</li></ol></li></ol></li><li>GC如何判断对象可以被回收<ol><li>引用计数法<ol><li>优点：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。</li><li>缺点：难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。</li></ol></li><li>可达性分析法<ol><li>可达性分析是用来判断对象是否存活，通过"GC Roots"作为起点，从这个节点往下搜索，如果有有引用，则这个对象是存活的，如果没有则判定可回收的对象。</li></ol></li></ol></li><li>垃圾回收算法<ol><li>标记-清除算法<ol><li>标记-清除算法对<strong>根集合</strong>进行扫描，对<strong>存活</strong>的对象进行标记。标记完成后，再对整个空间内<strong>未被标记</strong>的对象扫描，进行回收。</li><li>优点：实现简单，不需要进行对象进行移动。</li><li>缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</li></ol></li><li>复制算法<ol><li>它将内存区域划分成相同的两个<strong>内存块</strong>。每次仅使用一半的空间，<code>JVM</code>生成的新对象放在一半空间中。当一半空间用完时进行<code>GC</code>，把可到达对象复制到另一半空间，然后把使用过的内存空间一次清理掉。</li><li>优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</li><li>缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</li></ol></li><li>标记-整理算法<ol><li><strong>标记-整理算法</strong> 采用和 <strong>标记-清除算法</strong> 一样的方式进行对象的标记，但后续不直接对可回收对象进行清理，而是将所有的<strong>存活对象</strong>往一端<strong>空闲空间</strong>移动，然后清理掉端边界以外的内存空间。</li><li>优点：解决了标记-清理算法存在的内存碎片问题。</li><li>缺点：仍需要进行局部对象移动，一定程度上降低了效率。</li></ol></li><li>分代收集算法</li><li>总结<ol><li>JDK8堆内存一般是划分为年轻代和老年代，不同年代 根据自身特性采用不同的垃圾收集算法。</li><li>对于新生代，每次GC时都有大量的对象死亡，只有少量对象存活。考虑到复制成本低，适合采用复制算法。因此有了From Survivor和To Survivor区域。</li><li><strong>对于老年代，因为对象存活率高</strong>，没有额外的内存空间对它进行担保。因而适合采用标记-清理算法和标记-整理算法进行回收。</li></ol></li></ol></li><li>JVM中哪些是线程共享区<ol><li>堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的<ol><li>堆: 不用多说了,放对象的地方</li><li>方法区: 类定义的成员变量丶常量丶静态变量丶方法都在这里</li><li>栈: 程序运行才有的,会把运行时的方法压入栈,里面有局部变量等东西</li><li>本地方法栈: 操作系统方法</li><li>程序计数器: 标记代码走到哪里了</li></ol></li></ol></li><li>你们项目如何排查JVM问题</li><li>一个对象从加载到JVM，再到被GC清除，都经历了什么过程？</li><li>什么是三色标记？</li><li>CMS怎么进行垃圾回收的？<ol><li>官方名称：最大-并发-标记-清除-垃圾收集器</li><li>作用范围：老年代</li><li>算法：并发标记清除算法。</li><li>阶段<ol><li>初始标记（CMS initial mark）<ol><li>STW</li></ol></li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ol></li></ol></li><li>JVM参数有哪些？
1. -Xms：设置初始分配大小，默认为物理内存的1/64 
2. -Xmx：最大分配内存，默认为物理内存的1/4
3. -XX:+PrintGCDetails：输出详细的GC处理日志 
4. -XX:+PrintGCTimeStamps：输出GC的时间戳信息 
5. -XX:+PrintGCDateStamps：输出GC的时间戳信息（以日期的形式）
6. -XX:+PrintHeapAtGC：在GC进行处理的前后打印堆内存信息 
7. -Xloggc:(SavePath)：设置日志信息保存文件 
8. 在堆内存的调整策略中，基本上只要调整两个参数：-Xms和-Xmx </li><li>GC具体过程<ol><li>当现在有一个新的对象产生，JvM需要为该对象进行内存空间的申请</li><li>先判断Eden区是否有内存空间，如果有，直接将新对象保存在Eden区</li><li>如果Eden区的内存空间不足，会自动执行一个MinorGC操作，将Eden区的无用内存空间进行清理</li><li>清理Eden区之后继续判断Eden区内存空间情况，如果充足，则将新对象直接保存在Eden区</li><li>如果执行了Minor GC之后发现Eden区的内存依然不足，那就判断存活区的内存空间，并将Eden区的部
分活跃对象保存在存活区</li><li>活跃对象迁移到存活区后，继续判断Eden区内存空间情况，如果充足，则将新对象直接保存在Eden区</li><li>如果存活区也没有空间了，则继续判断老年区，如果老年区充足，则将存活区的部分活跃对象保存在老
年区</li><li>存活区的活跃对象迁移到老年区后，则将Eden区的部分活跃对象保存在存活区</li><li>活跃对象迁移到存活区后，继续判断Eden区内存空间情况，如果充足，则将新对象直接保存在Eden区</li><li>如果老年区也满了，这时候产生Major GC (Ful GC)进行老年区的内存清理</li><li>如果老年区执行了 Major GC之后发现无法进行对象保存，会产生OutofMemoryError异常</li></ol></li><li>GC的区别</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=mi>1</span><span class=err>、部分收集（</span><span class=n>Partial</span> <span class=n>GC</span><span class=err>）：只针对部分区域进行垃圾收集。其中又分为：</span>
</span></span><span class=line><span class=cl>	<span class=mf>1.1</span><span class=err>、新生代收集（</span><span class=n>Minor</span> <span class=n>GC</span><span class=o>/</span><span class=n>Young</span> <span class=n>GC</span><span class=err>）：只针对新生代的垃圾收集。具体点的是</span><span class=n>Eden</span><span class=err>区满时触发</span><span class=n>GC</span><span class=err>。</span>
</span></span><span class=line><span class=cl>										<span class=n>Survivor</span><span class=err>满不会触发</span><span class=n>Minor</span> <span class=n>GC</span> <span class=err>。</span>
</span></span><span class=line><span class=cl>	<span class=mf>1.2</span><span class=err>、老年代收集（</span><span class=n>Major</span> <span class=n>GC</span><span class=o>/</span><span class=n>Old</span> <span class=n>GC</span><span class=err>）：只针对</span> <span class=err>老年代的垃圾收集。</span>
</span></span><span class=line><span class=cl>		<span class=err>目前，只有</span><span class=n>CMS</span><span class=err>收集器会有单独收集老年代的行为。</span>
</span></span><span class=line><span class=cl>		<span class=err>注意，很多时候，</span><span class=n>Major</span> <span class=n>GC</span> <span class=err>会和</span><span class=n>Full</span> <span class=n>GC</span><span class=err>混淆使用，需要具体分辨是老年代的回收还是整堆回收。</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=mf>1.3</span><span class=err>、混合收集（</span><span class=n>Mixed</span> <span class=n>GC</span><span class=err>）：指目标是收集整个新生代以及部分老年代的垃圾收集。</span>
</span></span><span class=line><span class=cl>		<span class=err>目前只有</span><span class=n>G1</span><span class=err>收集器会有这种行为。</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl><span class=mi>2</span><span class=err>、整堆收集（</span><span class=n>Full</span> <span class=n>GC</span><span class=err>）：收集整个</span><span class=n>Java</span><span class=err>堆和方法区的垃圾收集。</span>	
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://luolin1024.github.io/tags/%E9%9D%A2%E8%AF%95/>面试</a></li></ul><nav class=paginav><a class=prev href=https://luolin1024.github.io/blog_prepublish/%E9%9D%A2%E8%AF%95/mysql/><span class=title>« Prev</span><br><span>Mysql知识</span></a>
<a class=next href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/><span class=title>Next »</span><br><span>设计模式</span></a></nav><div class=related-posts><h2>相关文章</h2><ul><li>· <a href=/blog_prepublish/%E9%9D%A2%E8%AF%95/spring/>Spring知识</a></li><li>· <a href=/blog_prepublish/%E9%9D%A2%E8%AF%95/%E7%BC%93%E5%AD%98/>缓存知识</a></li><li>· <a href=/blog_prepublish/%E9%9D%A2%E8%AF%95/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/>消息队列知识</a></li><li>· <a href=/blog_prepublish/%E9%9D%A2%E8%AF%95/mybatis/>MyBatis知识</a></li><li>· <a href=/blog_prepublish/%E9%9D%A2%E8%AF%95/mysql/>Mysql知识</a></li></ul></div></footer><link rel=stylesheet href=https://unpkg.com/@waline/client@v2/dist/waline.css><div id=waline></div><script type=module>
    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
    const locale = {
        nick: '昵称',
        nickError: '请填写昵称',
        mail: '邮箱',
        mailError: '请填写正确的邮件地址',
        link: '网址',
        optional: '可选',
        placeholder: '仅填写昵称即可发表回复。\n填写邮箱可收到回复提醒。\n评论区支持 Markdown 语法及预览。\n',
        sofa: '来发评论吧~',
        submit: '提交',
        like: '喜欢',
        cancelLike: '取消喜欢',
        reply: '回复',
        cancelReply: '取消回复',
        comment: '评论',
        refresh: '刷新',
        more: '加载更多...',
        preview: '预览',
        emoji: '表情',
        uploadImage: '上传图片',
        seconds: '秒前',
        minutes: '分钟前',
        hours: '小时前',
        days: '天前',
        now: '刚刚',
        uploading: '正在上传',
        login: '管理',
        logout: '退出',
        admin: '博主',
        sticky: '置顶',
        word: '字',
        wordHint: '评论字数应在 $0 到 $1 字之间！\n当前字数：$2',
        anonymous: '匿名',
        level0: '潜水',
        level1: '冒泡',
        level2: '吐槽',
        level3: '活跃',
        level4: '话痨',
        level5: '传说',
        gif: '表情包',
        gifSearchPlaceholder: '搜索表情包',
        profile: '个人资料',
        approved: '通过',
        waiting: '待审核',
        spam: '垃圾',
        unsticky: '取消置顶',
        oldest: '按倒序',
        latest: '按正序',
        hottest: '按热度',
        reactionTitle: '你认为这篇文章怎么样？',
    };
    init({
        
        el: '#waline',
        serverURL: 'https://blogcomments.luolin.online',
        locale,
        emoji: false,     
        search: false,    
        reaction: false,  
        requiredMeta: ['nick'],
        pageSize: 10,
        imageUploader: false,
        copyright: true,
        pageview: true,
        like: false,
    });
</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://luolin1024.github.io>luolin1024</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div>本站总访问量 <span id=umami_value_site_pv></span> 次
本站总访客数 <span id=umami_value_site_uv></span> 人
当前在线访客 <span id=umami_value_active_uv></span> 人</div><a href="https://icp.gov.moe/?keyword=20248618" target=_blank>萌ICP备20248618号</a></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>