<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring知识 | luolin1024</title><meta name=keywords content="面试"><meta name=description content="Spring IOC与DI IOC：在Spring框架中实现控制反转的是Spring IoC容器，其具体就是由容器来控制对象的生命周期和业务对象之间的依赖关"><meta name=author content="luolin"><link rel=canonical href=https://luolin1024.github.io/blog_prepublish/%E9%9D%A2%E8%AF%95/spring/><script defer src=https://blogcounter.luolin.us.kg/script.js data-website-id=c8850e2c-16aa-465e-aa6f-5392c9397317></script>
<script src=/js/umami-stats.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script>
<link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luolin1024.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://luolin1024.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://luolin1024.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://luolin1024.github.io/apple-touch-icon.png><link rel=mask-icon href=https://luolin1024.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><html><head><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css><style>body{font-family:lxgw wenkai lite,sans-serif;font-family:lxgw wenkai screen,sans-serif}</style></head></html><meta property="og:title" content="Spring知识"><meta property="og:description" content="Spring IOC与DI IOC：在Spring框架中实现控制反转的是Spring IoC容器，其具体就是由容器来控制对象的生命周期和业务对象之间的依赖关"><meta property="og:type" content="article"><meta property="og:url" content="https://luolin1024.github.io/blog_prepublish/%E9%9D%A2%E8%AF%95/spring/"><meta property="article:section" content="blog_prepublish"><meta property="article:published_time" content="2024-02-21T11:30:51+08:00"><meta property="article:modified_time" content="2024-03-21T00:55:28+08:00"><meta property="og:site_name" content="luolin的博客"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spring知识"><meta name=twitter:description content="Spring IOC与DI IOC：在Spring框架中实现控制反转的是Spring IoC容器，其具体就是由容器来控制对象的生命周期和业务对象之间的依赖关"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog_prepublishes","item":"https://luolin1024.github.io/blog_prepublish/"},{"@type":"ListItem","position":2,"name":"Spring知识","item":"https://luolin1024.github.io/blog_prepublish/%E9%9D%A2%E8%AF%95/spring/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring知识","name":"Spring知识","description":"Spring IOC与DI IOC：在Spring框架中实现控制反转的是Spring IoC容器，其具体就是由容器来控制对象的生命周期和业务对象之间的依赖关","keywords":["面试"],"articleBody":"Spring IOC与DI IOC：在Spring框架中实现控制反转的是Spring IoC容器，其具体就是由容器来控制对象的生命周期和业务对象之间的依赖关系，而不是像传统方式(new 对象)中由代码来直接控制。 DI，依赖注入；IoC和DI其实是同一个概念，只是从不同的角度描述罢了(IoC是一种思想，而DI则是一种具体的技术实现手段)。 构造函数注入 set方法注入 注解注入 优点 第一，资源集中管理，实现资源的可配置和易管理 第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度 AOP [[Spring中利用AOP使用自定义注解]] [[Spring AOP注解常见问题]]\nBean Bean的作用域 - singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。 - 单例 bean 的线程安全问题 - 单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。 - prototype : 每次请求都会创建一个新的 bean 实例。 - request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。 - session : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。 - global-session ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。 Bean的生命周期（4个阶段） 实例化 Bean 容器找到配置文件中 Spring Bean 的定义。 实例化一个 bean 对象 属性赋值 为 bean 设置相关属性和依赖 初始化 初始化前 检查Aware相关接口并设置相关依赖【扩展点】 BeanPostProcessor前置处理【扩展点】 初始化 是否实现InitializingBean接口【扩展点】 BeanPostProcessor前置处理后置处理【扩展点】 销毁 注册 Destruction相关回调接口【扩展点】 使用中 是否实现了 DisposableBean 接口，执行 destroy() 方法。【扩展点】 如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。 扩展点： Aware 接口 BeanPostProcessor 是 Spring 为修改 bean提供的强大扩展点，其可作用于容器中所有 bean，初始化 InitializingBean 和 init-method 是 Spring 为 bean 初始化提供的扩展点。 总结一下：\n4个大的阶段：实例化、属性赋值、初始化、销毁 初始化的具体操作，有Aware接口的依赖注入、BeanPostProcessor在初始化前后的处理以及InitializingBean和init-method 的初始化操作 销毁的具体操作，有注册销毁回调接口，最后通过 DisposableBean和 destroy-method 实现销毁 Spring启动流程 初始化Spring容器，注册内置的BeanPostProcessor的BeanDefinition到容器中 实例化BeanFactory【DefaultListableBeanFactory】工厂，用于生成Bean对象 实例化BeanDefinitionReader注解配置读取器，用于对特定注解（如@Service、@Repository）的类进行读取转化成 BeanDefinition 对象，（BeanDefinition 是 Spring 中极其重要的一个概念，它存储了 bean 对象的所有特征信息，如是否单例，是否懒加载，factoryBeanName 等） 实例化ClassPathBeanDefinitionScanner路径扫描器，用于对指定的包目录进行扫描查找 bean 对象 将配置类的BeanDefinition注册到容器中 调用refresh()方法刷新容器 SpringMVC Spring事务 Spring 管理事务的方式 编程式事务 在代码中硬编码(不推荐使用) : 通过 TransactionTemplate或者 TransactionManager 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。 声明式事务 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多） 事务传播行为 Spring是什么？ 谈谈你对AOP的理解 面向切面编程 JDK动态代理 CGLib动态代理 谈谈你对IOC的理解 控制反转 简单理解：传统开发中，我们在对象内部通过new关键字，创建依赖的对象，我们主动控制依赖的对象；而IoC有专门一个容器来创建依赖对象，对象内部只是被动的接受这些依赖的对象。上面就解释了“控制反转”：依赖对象的获取给反转了。之前，依赖对象由对象内部主动创建获取，现在，依赖对象由容器创建，对象从容器中获取依赖对象。 解释下Spring支持的几种bean的作用域 5种作用域 spring事务的实现方式和原理以及隔离级别？ AOP，4个隔离级别，RU、RC、RR、串行 三个问题： 幻读： 脏读： 不可重复读 Spring事务传播机制 Spring事务什么时候会失效？ 什么是bean的自动装配，有哪些方式？ Spring中的Bean创建的生命周期有哪些步骤 Spring中Bean是线程安全的吗 不是线程安全的 ApplicationContext和BeanFactory有什么区别 Spring中的事务是如何实现的 AOP Spring中什么时候@Transactional会失效 Spring容器启动流程是怎样的 Spring用到了哪些设计模式 工厂设计模式：BeanFactory、ApplicationContext 单例模式 代理设计模式 模板方法：jdbcTemplate、hibernateTemplate 观察者模式：ApplicationEvent，ApplicationListener 适配器模式：Spring AOP 的增强或通知(Advice)使用到了适配器模式、SpringMVC中的Controller Spring Boot、 Spring MVC 和 Spring 有什么区别 ","wordCount":"2263","inLanguage":"en","datePublished":"2024-02-21T11:30:51+08:00","dateModified":"2024-03-21T00:55:28+08:00","author":{"@type":"Person","name":"luolin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://luolin1024.github.io/blog_prepublish/%E9%9D%A2%E8%AF%95/spring/"},"publisher":{"@type":"Organization","name":"luolin1024","logo":{"@type":"ImageObject","url":"https://luolin1024.github.io/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luolin1024.github.io accesskey=h title="luolin的博客 (Alt + H)">luolin的博客</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://luolin1024.github.io/posts title=📚文章><span>📚文章</span></a></li><li><a href=https://luolin1024.github.io/archives/ title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luolin1024.github.io/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luolin1024.github.io/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luolin1024.github.io/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luolin1024.github.io/links title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://luolin1024.github.io>Home</a>&nbsp;»&nbsp;<a href=https://luolin1024.github.io/blog_prepublish/>Blog_prepublishes</a></div><h1 class="post-title entry-hint-parent">Spring知识</h1><div class=post-meta><span title='2024-02-21 11:30:51 +0800 +0800'>2024-02-21</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2263 words&nbsp;·&nbsp;luolin
本文总阅读量 <span id=umami_value_page_pv></span> 次
本文总访客量 <span id=umami_value_page_uv></span> 人</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#spring aria-label=Spring>Spring</a><ul><li><a href=#ioc%e4%b8%8edi aria-label=IOC与DI>IOC与DI</a></li><li><a href=#aop aria-label=AOP>AOP</a></li><li><a href=#bean aria-label=Bean>Bean</a><ul><li><a href=#bean%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label=Bean的作用域>Bean的作用域</a></li><li><a href=#bean%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f4%e4%b8%aa%e9%98%b6%e6%ae%b5 aria-label=Bean的生命周期（4个阶段）>Bean的生命周期（4个阶段）</a></li></ul></li><li><a href=#spring%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b aria-label=Spring启动流程>Spring启动流程</a></li><li><a href=#springmvc aria-label=SpringMVC>SpringMVC</a></li><li><a href=#spring%e4%ba%8b%e5%8a%a1 aria-label=Spring事务>Spring事务</a><ul><li><a href=#%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e8%a1%8c%e4%b8%ba aria-label=事务传播行为>事务传播行为</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=spring>Spring<a hidden class=anchor aria-hidden=true href=#spring>#</a></h2><h3 id=ioc与di>IOC与DI<a hidden class=anchor aria-hidden=true href=#ioc与di>#</a></h3><ul><li>IOC：在Spring框架中实现控制反转的是Spring IoC容器，其具体就是由容器来控制对象的生命周期和业务对象之间的依赖关系，而不是像传统方式(new 对象)中由代码来直接控制。</li><li>DI，依赖注入；IoC和DI其实是同一个概念，只是从不同的角度描述罢了(IoC是一种思想，而DI则是一种具体的技术实现手段)。<ul><li>构造函数注入</li><li>set方法注入</li><li>注解注入</li></ul></li><li>优点<ul><li>第一，资源集中管理，实现资源的可配置和易管理</li><li>第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度</li></ul></li></ul><h3 id=aop>AOP<a hidden class=anchor aria-hidden=true href=#aop>#</a></h3><p>[[Spring中利用AOP使用自定义注解]]
[[Spring AOP注解常见问题]]</p><h3 id=bean>Bean<a hidden class=anchor aria-hidden=true href=#bean>#</a></h3><h4 id=bean的作用域>Bean的作用域<a hidden class=anchor aria-hidden=true href=#bean的作用域>#</a></h4><pre><code>- singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。
	- 单例 bean 的线程安全问题
	- 单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。
- prototype : 每次请求都会创建一个新的 bean 实例。
- request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。
- session : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。
- global-session ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。
</code></pre><h4 id=bean的生命周期4个阶段>Bean的生命周期（4个阶段）<a hidden class=anchor aria-hidden=true href=#bean的生命周期4个阶段>#</a></h4><ol><li>实例化<ol><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>实例化一个 bean 对象</li></ol></li><li>属性赋值<ol><li>为 bean 设置相关属性和依赖</li></ol></li><li>初始化<ol><li>初始化前<ol><li>检查Aware相关接口并设置相关依赖【扩展点】</li><li>BeanPostProcessor前置处理【扩展点】</li></ol></li><li>初始化<ol><li>是否实现InitializingBean接口【扩展点】</li><li>BeanPostProcessor前置处理后置处理【扩展点】</li></ol></li></ol></li><li>销毁<ol><li>注册 Destruction相关回调接口【扩展点】</li><li>使用中</li><li>是否实现了 DisposableBean 接口，执行 destroy() 方法。【扩展点】</li><li>如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。
扩展点：</li></ol></li><li>Aware 接口</li><li>BeanPostProcessor 是 Spring 为<strong>修改 bean</strong>提供的强大扩展点，其可作用于容器中所有 bean，初始化</li><li>InitializingBean 和 init-method 是 Spring 为 <strong>bean 初始化</strong>提供的扩展点。</li></ol><p>总结一下：</p><ol><li>4个大的阶段：实例化、属性赋值、初始化、销毁</li><li>初始化的具体操作，有Aware接口的依赖注入、BeanPostProcessor在初始化前后的处理以及InitializingBean和init-method 的初始化操作</li><li>销毁的具体操作，有注册销毁回调接口，最后通过 DisposableBean和 destroy-method 实现销毁</li></ol><h3 id=spring启动流程>Spring启动流程<a hidden class=anchor aria-hidden=true href=#spring启动流程>#</a></h3><ol><li>初始化Spring容器，注册内置的BeanPostProcessor的BeanDefinition到容器中<ol><li>实例化BeanFactory【DefaultListableBeanFactory】工厂，用于生成Bean对象</li><li>实例化BeanDefinitionReader注解配置读取器，用于对特定注解（如@Service、@Repository）的类进行读取转化成 BeanDefinition 对象，（BeanDefinition 是 Spring 中极其重要的一个概念，它存储了 bean 对象的所有特征信息，如是否单例，是否懒加载，factoryBeanName 等）</li><li>实例化ClassPathBeanDefinitionScanner路径扫描器，用于对指定的包目录进行扫描查找 bean 对象</li></ol></li><li>将配置类的BeanDefinition注册到容器中</li><li>调用refresh()方法刷新容器</li></ol><h3 id=springmvc>SpringMVC<a hidden class=anchor aria-hidden=true href=#springmvc>#</a></h3><h3 id=spring事务>Spring事务<a hidden class=anchor aria-hidden=true href=#spring事务>#</a></h3><ul><li>Spring 管理事务的方式<ul><li>编程式事务<ul><li>在代码中硬编码(不推荐使用) : 通过 TransactionTemplate或者 TransactionManager 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li></ul></li><li>声明式事务<ul><li>在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）</li></ul></li></ul></li></ul><h4 id=事务传播行为>事务传播行为<a hidden class=anchor aria-hidden=true href=#事务传播行为>#</a></h4><p><div class=post-img-view><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/luolin1024/image@main/img/20230906161905.png><img src=https://cdn.jsdelivr.net/gh/luolin1024/image@main/img/20230906161905.png alt=image.png></a></div></p><ol><li>Spring是什么？</li><li>谈谈你对AOP的理解<ol><li>面向切面编程</li><li>JDK动态代理</li><li>CGLib动态代理</li></ol></li><li>谈谈你对IOC的理解<ol><li>控制反转</li><li><strong>简单理解</strong>：传统开发中，我们在对象内部通过new关键字，创建依赖的对象，我们主动控制依赖的对象；而IoC有专门一个容器来创建依赖对象，对象内部只是被动的接受这些依赖的对象。上面就解释了“控制反转”：依赖对象的获取给反转了。之前，依赖对象由对象内部主动创建获取，现在，依赖对象由容器创建，对象从容器中获取依赖对象。</li></ol></li><li>解释下Spring支持的几种bean的作用域<ol><li>5种作用域</li><li></li></ol></li><li>spring事务的实现方式和原理以及隔离级别？<ol><li>AOP，4个隔离级别，RU、RC、RR、串行</li><li>三个问题：<ol><li>幻读：</li><li>脏读：</li><li>不可重复读</li></ol></li></ol></li><li>Spring事务传播机制</li><li>Spring事务什么时候会失效？</li><li>什么是bean的自动装配，有哪些方式？</li><li>Spring中的Bean创建的生命周期有哪些步骤</li><li>Spring中Bean是线程安全的吗<ol><li>不是线程安全的</li></ol></li><li>ApplicationContext和BeanFactory有什么区别</li><li>Spring中的事务是如何实现的<ol><li>AOP</li></ol></li><li>Spring中什么时候@Transactional会失效</li><li>Spring容器启动流程是怎样的</li><li>Spring用到了哪些设计模式<ol><li>工厂设计模式：BeanFactory、ApplicationContext</li><li>单例模式</li><li>代理设计模式</li><li>模板方法：jdbcTemplate、hibernateTemplate</li><li>观察者模式：ApplicationEvent，ApplicationListener</li><li>适配器模式：Spring AOP 的增强或通知(Advice)使用到了适配器模式、SpringMVC中的Controller</li></ol></li><li>Spring Boot、 Spring MVC 和 Spring 有什么区别</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://luolin1024.github.io/tags/%E9%9D%A2%E8%AF%95/>面试</a></li></ul><nav class=paginav><a class=prev href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/spring/spring%E4%BA%8B%E5%8A%A1%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E5%B5%8C%E5%A5%97/><span class=title>« Prev</span><br><span>Spring事务以及事务嵌套</span></a>
<a class=next href=https://luolin1024.github.io/blog_prepublish/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/java/spring/spring%E7%BB%84%E4%BB%B6/><span class=title>Next »</span><br><span>Spring组件</span></a></nav><div class=related-posts><h2>相关文章</h2><ul><li>· <a href=/blog_prepublish/%E9%9D%A2%E8%AF%95/%E7%BC%93%E5%AD%98/>缓存知识</a></li><li>· <a href=/blog_prepublish/%E9%9D%A2%E8%AF%95/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/>消息队列知识</a></li><li>· <a href=/blog_prepublish/%E9%9D%A2%E8%AF%95/mybatis/>MyBatis知识</a></li><li>· <a href=/blog_prepublish/%E9%9D%A2%E8%AF%95/mysql/>Mysql知识</a></li><li>· <a href=/blog_prepublish/%E9%9D%A2%E8%AF%95/java/>Java知识</a></li></ul></div></footer><link rel=stylesheet href=https://unpkg.com/@waline/client@v2/dist/waline.css><div id=waline></div><script type=module>
    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
    const locale = {
        nick: '昵称',
        nickError: '请填写昵称',
        mail: '邮箱',
        mailError: '请填写正确的邮件地址',
        link: '网址',
        optional: '可选',
        placeholder: '仅填写昵称即可发表回复。\n填写邮箱可收到回复提醒。\n评论区支持 Markdown 语法及预览。\n',
        sofa: '来发评论吧~',
        submit: '提交',
        like: '喜欢',
        cancelLike: '取消喜欢',
        reply: '回复',
        cancelReply: '取消回复',
        comment: '评论',
        refresh: '刷新',
        more: '加载更多...',
        preview: '预览',
        emoji: '表情',
        uploadImage: '上传图片',
        seconds: '秒前',
        minutes: '分钟前',
        hours: '小时前',
        days: '天前',
        now: '刚刚',
        uploading: '正在上传',
        login: '管理',
        logout: '退出',
        admin: '博主',
        sticky: '置顶',
        word: '字',
        wordHint: '评论字数应在 $0 到 $1 字之间！\n当前字数：$2',
        anonymous: '匿名',
        level0: '潜水',
        level1: '冒泡',
        level2: '吐槽',
        level3: '活跃',
        level4: '话痨',
        level5: '传说',
        gif: '表情包',
        gifSearchPlaceholder: '搜索表情包',
        profile: '个人资料',
        approved: '通过',
        waiting: '待审核',
        spam: '垃圾',
        unsticky: '取消置顶',
        oldest: '按倒序',
        latest: '按正序',
        hottest: '按热度',
        reactionTitle: '你认为这篇文章怎么样？',
    };
    init({
        
        el: '#waline',
        serverURL: 'https://blogcomments.luolin.online',
        locale,
        emoji: false,     
        search: false,    
        reaction: false,  
        requiredMeta: ['nick'],
        pageSize: 10,
        imageUploader: false,
        copyright: true,
        pageview: true,
        like: false,
    });
</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://luolin1024.github.io>luolin1024</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div>本站总访问量 <span id=umami_value_site_pv></span> 次
本站总访客数 <span id=umami_value_site_uv></span> 人
当前在线访客 <span id=umami_value_active_uv></span> 人</div><a href="https://icp.gov.moe/?keyword=20248618" target=_blank>萌ICP备20248618号</a></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>